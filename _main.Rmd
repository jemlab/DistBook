---
title: "&nbsp;"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: false
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: false
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

```{css,echo=FALSE}
.title{
  display: none;
}
```

<div class="container">
<div class="landing">
<div class="landing-left">
<div class="landing-subtitle">
## NBIS • Workshop
</div>
<div class="landing-title">
# R Programming Foundations for Life Scientist
</div>
<div class="landing-features">
- Data structures
- Logic and control structures
- Input/Output
- Data wrangling
- Base and ggplot graphics
</div>
</div>
<div class="landing-right">
<img src="assets/landing.png">
</div>
</div>

***

<div class="landing-update">
<p class="small" style="color:#bdbdbd;">
`r paste("Last updated on",fontawesome::fa("calendar-alt",fill="#bdbdbd"),format(Sys.time(),format='%d-%b-%Y'),"at",fontawesome::fa("clock",fill="#bdbdbd"),format(Sys.time(),format='%X'),".")`
</p>
</div>

</div>

<!--chapter:end:index.Rmd-->

---
title: "Content"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: false
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: false
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

This page contains links to different lectures (slides) and practical exercises (labs) that are part of this workshop. The links below are similar to that under [Schedule](home_schedule.html) but organised here by topic.

**Basics**

* [Intro to R (Slides)](slide_r_intro.html)  
* [Intro to R environment (Slides)](slide_r_environment.html)
* [Intro to programming in R (Slides)](slide_r_programming_1.html)  
* [Variables and Operators (Slides)](slide_elements_1.pdf)  
* [Data types (Lab)](lab_datatypes.html)  
* [Vectors and Strings (Slides)](slide_elements_2.pdf)  
* [Matrices, Lists and Dataframes (Slides)](slide_elements_3.pdf)  
* [Working with Vectors (Lab)](lab_vectors.html)
* [Dataframes (Lab)](lab_dataframes.html)

**Data wrangling**

* [Loading data (Slides)](slide_loadingdata.pdf)
* [Loading data (Lab)](lab_loadingdata.html)  
* [Tidyverse (Slides)](slide_tidyverse.html)  
* [Tidyverse (Lab)](lab_tidyverse.html)  

**Graphics**

* [Graphics with base R (Slides)](slide_graphics.pdf)  
* [Graphics with base R (Lab)](lab_graphics.html)  
* [Graphics with ggplot2 (Slides)](slide_ggplot2.html)  
* [Working with ggplot2 (Lab)](lab_ggplot2.html)  

**Other**

* [R package anatomy (Slides)](slide_rpackage.html)  

**Useful resources**

* [Data structures in R](data/common/R_data_structures_ver_1_1.pdf)  
* [Color names in R](data/common/Rolor.pdf)  
* [Visualising data](data/common/rules_for_using_color.pdf)  
* [Naming conventions in R](data/common/Rnaming.pdf)  
* [Introduction to statistical tests in R](data/common/stats_tests.pdf)  


***

<!--chapter:end:home_content.Rmd-->

---
title: "Info"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: false
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: false
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

## Location

```{r,eval=TRUE,include=FALSE}
library(yaml)
library(leaflet)

# set location in _site.yml
loc <- yaml::read_yaml("_site.yml")$location

if(loc=="lund") {
  dfr <- data.frame(venue_lat=55.713394,
                    venue_lon=13.206628,
                    venue_address="<b>Department of Biology</b>,Building D, Room Retina D227, Sölvegatan 35,Lund Sweden",
                    description="For Lund city buses, regional buses and regional trains, [click here](https://www.skanetrafiken.se/). You can buy a ticket at the central station in Lund or at the regional bus (card only). You can also use the app [Skånetrafiken](https://www.skanetrafiken.se/biljetter/app2/)",
                    stringsAsFactors=F)
}

if(loc=="umea") {
  dfr <- data.frame(venue_lat=63.820019,
                    venue_lon=20.307814,
                    venue_address="<b>Department of Science and Mathematics Education</b>,Naturvetarhuset A,Umeå University,Universums gränd,90736 Umeå,Sweden",
                    description="[Umeå city buses](http://tabussen.nu/):<br>Pay your bus ticket on the bus (credit card only), or in advance in the ticket machines at Vasaplan or Umeå Airport, or at any Reseinfo centre. It is cheaper to buy the ticket in advance. You can also use the app [Ultra vill mer](https://www.tabussen.nu/ultra/biljetter/appen-ultra-vill-mer/). The bus stop in the city centre is *Vasaplan* and the stop near the course venue is *Universum*. Bus options are 2,5,8 or 9 and takes about 6-7 min.<br><br>[Airport bus](https://www.tabussen.nu/flygbussen/english/):<br>The airport bus (Bus 80) goes from the airport to *Vasaplan* (the city centre), and then passes NUS and Umeå Campus on the way back. The trip takes about 8 min from the airport to *Vasaplan*, and about 15 min the other way. It stops at *Universum* (Umeå Campus) approx. 5 min after leaving *Vasaplan*.",
                    stringsAsFactors=F)
}

if(loc=="uppsala") {
  dfr <- data.frame(venue_lat=59.841949,
                    venue_lon=17.637073,
                    venue_address="<b>SciLifeLab</b>,Entrance C11,Biomedicinskt centrum,Uppsala University,Husargatan 3,75237 Uppsala,Sweden",
                    description="Use the [UL website](www.ul.se) or the [UL app](https://www.ul.se/en/tickets/how-to-buy-a-ticket/the-UL-app/) for bus and train services around Uppsala. For buses from the Centralstation (Train/Bus), take Bus 4 (towards Gottsunda Centrum) or 8 (towards Sunnersta) and get off at the stop *Uppsala Science Park*. Bus tickets can be purchased in the app or directly from the driver using a credit card.",
                    stringsAsFactors=F)
}

if(loc=="linkoping") {
  dfr <- data.frame(venue_lat=58.402748,
                    venue_lon=15.578822,
                    venue_address="<b>Linköping University</b>,Campus Valla, C-house, Entrance 12, 581 83 Linköping, Sweden",
                    description="Use the [Östgötatrafiken website](https://www.ostgotatrafiken.se) or the [Östgötatrafiken app](https://www.ostgotatrafiken.se/kundservice/hur-kan-vi-hjalpa-dig/nya-appen/) for bus services around Linköping. The easiest way to by tickets is through the app, but you can by a travel card in advance which you can load with tickets as described [here](https://www.ostgotatrafiken.se/biljetter/kopa-biljett/utan-app/). From Linköping Resecentrum, take bus 12 (towards Lambohov) or bus 543 (towards Slaka) and get off at the stop *Mäster Mattias väg*.",
                    stringsAsFactors=F)
}
```

```{r,eval=TRUE,echo=FALSE,chunk.title=NULL}
if(loc!="online") {
  address <- paste(unlist(strsplit(as.character(dfr$venue_address),split=",")),collapse="<br>")
  leaflet(height=450,width="auto") %>%
    addTiles(urlTemplate='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png') %>%
    addMarkers(lat=dfr$venue_lat,lng=dfr$venue_lon,popup=address) %>%
    setView(lat=dfr$venue_lat,lng=dfr$venue_lon,zoom=15)
}
```

```{r,eval=TRUE,echo=FALSE,chunk.title=NULL,results="asis"}
if(loc=="online") {
  cat("The workshop is online only. Zoom and Slack links are sent to participants by email.")
}
```

```{r,eval=TRUE,echo=FALSE,results="asis",chunk.title=NULL}
if(loc!="online") {
  cat("## Travel info")
  cat("\n",dfr$description)
}
```

## Contact

If you would like to get in touch with us regarding the contents of this workshop, please contact us at **edu.r [at] nbis.se**.

***

<!--chapter:end:home_info.Rmd-->

---
title: "Precourse"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: false
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: false
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

This workshop is aimed towards biologists, and other life sciences researchers with none or limited experience with R programming or even programming in general.

# &nbsp; {.tabset .tabset-fade}

## Preparation

### Tools

`r fa1("chevron-circle-right")` &nbsp; **Install R statistical software**

<div class="boxy boxy-exclamation boxy-yellow">

If you have an old version of R and you do not use it, uninstall it and then install a newer version. If you prefer to keep your old R version, then you can still install a newer version for this workshop. This is easy on Windows, but can be tricky on Linux.

</div>

Go to [r-project.org](https://cloud.r-project.org/) and choose the link appropriate for your operating system.

<img src="data/common/r-download.png" class="fancyimage">

<div class="boxy boxy-lightbulb">

**Installation details**

<i class="fab fa-windows"></i> **Windows:** Click **Download R for Windows** > **base** > **Download R X.X.X for Windows**. This should download an .exe file. It is recommended that you DO NOT install to `C:\Program Files\R\`. Instead, install to `C:\R\`. It is also recommended that you install Rtools for building R packages from source code. Click **Download R for Windows** > **Rtools**.

<i class="fab fa-apple"></i> **Mac:** Click **Download R for (Mac) OS X** > **R-X.X.X.pkg** that will download R to your computer. If you are not sure what version of Mac OS you are running, click the apple on the top left of your screen and select **About this mac** (Om den här datorn). In case you are running something older than 10.9, you should instead pick the “R-X.X.X-snowleopard.pkg” to install. Note that this will not give you the latest version of R, but it will be sufficient for most sections of the course. You can then double-click the downloaded package that will prompt you with some questions for installation details. Stick with the default settings and you should be fine.

<i class="fab fa-linux"></i> **Linux:** Click **Download R for Linux** then pick your distribution of Linux. On most distributions, this will be via a software install system like `yum` or `apt-get`. If you run this make sure that you update your information to the installer first, otherwise you might end up installing at outdated version of R. For some systems you might need to install not only **r-base**, but also **r-devel** or you will lack important features of your R installation. When installing R packages, you might need to install OS specific packages before. These are displayed during R package installation.

</div>

`r fa1("chevron-circle-right")` &nbsp; **Install [RStudio](https://rstudio.com/products/rstudio/download/#download)**. Choose based on your OS.

[![](data/common/rstudio.png)](https://rstudio.com/products/rstudio/download/#download)

RStudio provides you with tools like code editor with highlighting, project management, version control, package building, debugger, profiler and more. Start up RStudio to check that everything has been installed correctly. If not, contact us and we can help you out.

`r fa1("chevron-circle-right")` &nbsp; **Install R packages**

Extra R packages used in the workshop exercises (if any) are listed below. It is recommended that you install this in advance. Simply copy and paste the code into R.

```{r,eval=TRUE,chunk.title=NULL,echo=FALSE,comment="",class.output="r"}
# this code block reads package names from '_site.yml' and prints them as installation instruction.

pkg <- yaml::read_yaml("_site.yml")

if(!is.null(pkg$packages$packages_cran_student)) {
 cat("# install from cran\n")
 cat(paste0("install.packages(c('",paste(pkg$packages$packages_cran_student,sep="",collapse="','"),"'))"))
 cat("\n")
}

if(!is.null(pkg$packages$packages_bioc_student)) {
 cat("# install from bioconductor\n")
 cat(paste0("BiocManager::install(c('",paste(pkg$packages$packages_bioc_student,sep="",collapse="','"),"'))"))
}
```

`r fa1("chevron-circle-right")` &nbsp; **Install Docker**

It is NOT absolutely necessary to have Docker installed, but we are working on shipping the working course as a Docker container ready to run. In order to be able to use this functionality, please make sure you have [Docker Desktop](https://www.docker.com/get-started) installed and running on your machine.

`r fa1("chevron-circle-right")` &nbsp; **Install git**

In order to use RStudio's version control features, install [Git](https://git-scm.com/downloads) on your machine. This step is also NOT necessary, but to our experience learning and using git makes your life much easier.

`r fa1("chevron-circle-right")` &nbsp; **Install Zoom**

Go to [Zoom website](https://zoom.us) and follow installation instructions. Most likely, your University has already paid some pro plan and you should consult your local IT to get university account details.

***

## Syllabus

The syllabus for this workshop are as follows.

* General introduction to programming and R.
* R environment and RStudio IDE.
* Data types.
* Variables and operators.
* Input/Output.
* Control structures.
* Functions and variable scope.
* Base and ggplot2 graphics.
* Overview of R package anatomy.
* Brief introduction to Tidyverse.
* Brief introduction to RMarkdown.

***

## Learning outcomes

* Feeling comfortable while working with R in RStudio.
* Being able to read some data and perform basic data manipulation in R.
* Being able to perform some basic analysis and generate plots in R.
* Being able to generate a simple report.

***

#

<!--chapter:end:home_precourse.Rmd-->

---
title: "Schedule"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: false
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: false
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

```{r,eval=TRUE,include=FALSE}
library(lubridate)
library(dplyr)
library(kableExtra)
library(formattable)
library(yaml)
```

```{r,eval=TRUE,include=FALSE}
s <- read.csv("schedule.csv",sep=";",stringsAsFactors=F,header=T,na.strings="",colClasses="character")
# remove rows that are completely NA
s <- s[!apply(s,1,function(x) all(is.na(x))),]

s <- s %>%
  # missing values in date and room are filled
  tidyr::fill(date,room,link_room,.direction="down") %>%
  # convert date characters to date objects
  dplyr::mutate(date=format(as_datetime(date,format="%d/%m/%Y"),"%d-%b-%Y")) %>%
  dplyr::mutate(day=format(as_datetime(date,format="%d-%b-%Y"),"%a")) %>%
  dplyr::group_by(date) %>%
  dplyr::mutate(start_time=format(as_datetime(start_time,format="%H:%M"),"%H:%M"),
                end_time=format(as_datetime(end_time,format="%H:%M"),"%H:%M")) %>%
  as.data.frame() %>%
  dplyr::mutate(room=ifelse(is.na(link_room),room,paste0("<a href='",link_room,"'>",room,"</a>"))) %>%
  # create day label (with date, day, room)
  dplyr::mutate(date=paste0("<p style='font-size:110%;padding-top:10px;padding-bottom:5px;margin-top:10px;'><span style='font-weight:bold;'><span style='color:",color_primary,";'><i class='fas fa-calendar' style='margin-left:5px;margin-right:5px;'></i></span>",date,"</span>",
                     "<span style='color:white;border-radius:4px;padding-right:4px;padding-left:4px;background:",color_primary,";margin-left:9px;margin-right:7px;'>",day,"</span>",
                     "<span style='color:",color_primary,";'><i class='fas fa-map-marker-alt' style='margin-left:5px;margin-right:5px;'></i></span>",room,"</p>")) %>%
  # style topic
  dplyr::mutate(topic=ifelse(tolower(topic)=="coffee break" | tolower(topic)=="lunch",paste0("<span style='color:white;font-weight:bold;border-radius:4px;padding:4px;background:#BDBDBD;'>",topic,"</span>"),paste0("<span style='margin-right:5px;'>",topic,"</span>"))) %>%
  # add links to topic
  dplyr::mutate(topic=ifelse(is.na(link_slide),topic,paste0("<span>",topic,"<a href='",link_slide,"'><i class='fas fa-file-powerpoint' style='margin-left:4px;margin-right:4px;'></i></a></span>"))) %>%
  mutate(topic=ifelse(is.na(link_lab),topic,paste0("<span>",topic,"<a href='",link_lab,"'><i class='fas fa-file-alt' style='margin-left:4px;margin-right:4px;'></i></a></span>"))) %>%
  dplyr::mutate(time=paste0(start_time," - ",end_time)) %>%
  dplyr::mutate(teacher=ifelse(is.na(teacher),"",teacher)) %>%
  dplyr::mutate(assistant=ifelse(is.na(assistant),"",assistant)) %>%
  dplyr::select(date,room,time,topic,teacher,assistant)

if(all(is.na(s$assistant)) | all(s$assistant=="")) s$assistant <- NULL
```

<div class="table-schedule">

```{r,eval=TRUE,echo=FALSE,chunk.title=NULL}
# grouping vector
r <- rle(s$date)$length
names(r) <- rle(s$date)$values
cnames <- c("Time","Topic","Teacher","Assistant")

s %>%
  dplyr::select(-date,-room) %>%
  setNames(cnames[1:ncol(.)]) %>%
  kable(format="html",escape=FALSE) %>%
  kable_styling(bootstrap_options=c("hover","condensed"),position="center",full_width=TRUE) %>%
  column_spec(1,width="7em") %>%
  column_spec(2,width="16em") %>%
  pack_rows(index=r,label_row_css="background:white;",escape=F,indent=FALSE)
```

<!-- marker legend -->
<p class="small" style="margin-top:20px;">
<span>
<span style="margin-left:6px; margin-right:6px;">
<i class="fas fa-calendar" style="margin-left:4px; margin-right:4px;"></i> Date
</span>
<span style="margin-left:6px; margin-right:6px;">
<i class="fas fa-map-marker-alt" style="margin-left:4px; margin-right:4px;"></i> Venue
</span>
<span style="margin-left:6px; margin-right:6px;">
<i class="fas fa-file-powerpoint" style="margin-left:4px; margin-right:4px;"></i> Slides
</span>
<span style="margin-left:6px; margin-right:6px;">
<i class="fas fa-file-alt" style="margin-left:4px; margin-right:4px;"></i> Exercises
</span>
</span>
</p>

```{r,echo=FALSE,results='asis'}
# add assistant list if present
asst <- yaml::read_yaml("_site.yml")$assistant

if(!is.null(asst)) {
  cat('<p class="small" style="margin-top:20px;">',
           '<span style="margin-left:4px; margin-right:4px;"><i class="fas fa-users" style="margin-left:4px; margin-right:4px;"></i></span>',
           paste(asst,collapse=", "),
           '</p>')
}
```

</div>


<!--chapter:end:home_schedule.Rmd-->

---
title: "Matrices, Lists and Dataframes"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

# Introduction

A data set that have more than one dimension is conceptually hard to
store as a vector. For two-dimensional data set the solution to this
is to instead use matrices or data frames. As with vectors all values
in a matrix has to be of the same type (eg. you can not mix for
example characters and numerics in the same matrix). For data frames
this is not a requirement and different columns can have different
modes, but all columns in a data frame have the same number of
entries. In addition to these R also have objects named lists that can
store any type of data set and are not restricted by types or dimensions.

In this exercise you will learn how to:

- Create and work with matrices, data frames and lists  
- Perform basic math operator on matrices  
- Use functions to summarize information from data frames  
- Extract subsets of data from matrices, data frames and lists  
- Create S3 object from a list  


# Matrices

The command to create a matrix in R is `matrix()`.
As input it takes a vector of values, the number of
rows and the number of columns.

```{r}
X <- matrix(1:12, nrow = 4, ncol = 3)
X
```

Note that if one only specify the number of rows or columns the it
will infer the size of the matrix automatically using the size of
vector and the option given. The default way of filling the matrix is
column-wise, so the first values from the vector ends up in column 1
of the matrix. If you instead wants to fill the matrix row by row you
can set the byrow flag to TRUE.

```{r}
X <- matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE)
X
```

Subsetting a matrix is done the same way as for vectors, but you have
more than one dimension to work with. So you specify the rows and
column needed.

```{r}
X[1,2]
```

If one wants all values in a column or a row this can be specified by
leaving the other dimension empty, hence this code will print all
values in the second column.

```{r}
X[,2]
```

Note that if the retrieved part of a matrix can be represented as a
vector (eg one of the dimension have the length 1) R will convert it
to a vector otherwise it will still be a matrix.

## Exercise

<i class="fas fa-clipboard-list"></i> Create a matrix containing 1:12 as shown similar to the matrix X above.

1.  How do find out the length and the mode of the matrix?

```{r,accordion=TRUE}
mode(X)
length(X)
```

2.  Extract all the values in the matrix that is larger than 6.

```{r,accordion=TRUE}
X[X>6]
```

3.  Swap the positions of column 1 and 3 in the matrix X

```{r,accordion=TRUE}
X[,c(3,2,1)]
```

4.  Add a vector with three zeros as a fifth row to the matrix

```{r,accordion=TRUE}
X.2 <- rbind(X, rep(0, 3))
X.2
```

5.  Replace all values the first two columns in your matrix with `NA`.

```{r,accordion=TRUE}
X[,1:2] <- NA
X
```

6.  Replace all values in the matrix with 0 and convert it to a vector

```{r,accordion=TRUE}
X[] <- 0
as.vector(X)
```

7.  In the the earlier exercises, you created a vector with the names of the type Geno\_a\_1, Geno\_a\_2, Geno\_a\_3, Geno\_b\_1, Geno\_b\_2&#x2026;, Geno\_s\_3 using vectors. In today's lecture, a function named `outer()` that generates matrices was mentioned. Try to generate the same vector as yesterday using this function instead. The `outer()` function is very powerful, but can be hard to wrap you head around, so try to follow the logic, perhaps by creating a simple example to start with.

```{r}
letnum <- outer(paste("Geno",letters[1:19], sep = "_"), 1:3, paste, sep = "_")
class(letnum)
sort(as.vector(letnum))
```

8.  Create two different 2 by 2 matrices named A and B. A should contain the values 1-4 and B the values 5-8. Try out the following commands and by looking at the results see if you can figure out what is going on.

```
A. A * B
B. A / B
C. A %x% B
D. A + B
E. A - B
F. A == B
```

```{r,accordion=TRUE}
A <- matrix(1:4, ncol = 2, nrow = 2)
B <- matrix(5:8, ncol = 2, nrow = 2)
A
B

A * B
A / B
A %x% B
A + B
A - B
A == B
```

9. Generate a 10 by 10 matrix with random numbers. Add row and column names and calculate mean and median over rows and save these in a new matrix.

```{r,accordion=TRUE}
e <- rnorm(n = 100)
E <- matrix(e, nrow = 10, ncol = 10)
colnames(E) <- LETTERS[1:10]
rownames(E) <- colnames(E)
E.means <- rowMeans(E)
E.medians <- apply(E, MARGIN = 1, median)
E.mm <- rbind(E.means, E.medians)
E.mm
```

# Dataframes

Even though vectors are at the very base of R usage, data frames are central to R as the most common ways to import data into R (`read.table()`) will create a dataframe. Even though a dataframe can itself contain another dataframe, by far the most common dataframes consists of a set of equally long vectors. As dataframes can contain several different data types the command `str()` is very useful to run on dataframes.

```{r}
vector1 <- 1:10
vector2 <- letters[1:10]
vector3 <- rnorm(10, sd = 10)
dfr <- data.frame(vector1, vector2, vector3)
str(dfr)
```

In the above example, we can see that the dataframe **dfr** contains 10 observations for three variables that all have different modes, column 1 is an integer vector, column 2 a vector with **factors** and column 3 a numeric vector. It is noteworthy that the second column is a factor even though we just gave it a character vector.

## Exercise

1. Figure out what is going on with the second column in **dfr** dataframe described above and modify the creation of the dataframe so that the second column is stored as a character vector rather than a factor. Hint: Check the help for `data.frame` to find an argument that turns off the factor conversion.

```{r,accordion=TRUE}
dfr <- data.frame(vector1, vector2, vector3, stringsAsFactors = FALSE)
str(dfr)
```

2. One can select columns from a data frame using either the name or the position. Use both methods to print the last two columns from the **dfr** data frame.

```{r,accordion=TRUE}
dfr[,2:3]
dfr[,c("vector2", "vector3")]
```

3. Print all letters in the **vector2** column of the data frame where the **vector3** column has a positive value.

```{r,accordion=TRUE}
dfr[dfr$vector3>0,2]
dfr$vector2[dfr$vector3>0]
```

4. Create a new vector combining the all columns of **dfr** separated by a underscore.

```{r,accordion=TRUE}
paste(dfr$vector1, dfr$vector2, dfr$vector3, sep = "_")
```

5. There is a dataframe of car information that comes with the base installation of R. Have a look at this data by typing `mtcars`. How many rows and columns does it have?

```{r,accordion=TRUE}
dim(mtcars)
ncol(mtcars)
nrow(mtcars)
```

6. Re-arrange the row names of this dataframe and save as a vector.

```{r,accordion=TRUE}
car.names <- sample(row.names(mtcars))
```

7. Create a dataframe containing the vector from the previous question and two vectors with random numbers named random1 and random2.

```{r,accordion=TRUE}
random1 <- rnorm(length(car.names))
random2 <- rnorm(length(car.names))
mtcars2 <- data.frame(car.names, random1, random2)
mtcars2
```

8. Now you have two dataframes that both contains information on a set of cars. A collaborator asks you to create a new dataframe with all this information combined. Create a merged dataframe ensuring that rows match correctly.

```{r,accordion=TRUE}
mt.merged <- merge(mtcars, mtcars2, by.x = "row.names", by.y = "car.names")
mt.merged
```

9. Calculate the mean value for the two columns that you added to the **mtcars** data frame. Check out the function `colMeans()`.

```{r,accordion=TRUE}
colMeans(mtcars2[, c("random1", "random2")])
```

Try to modify so you get the mean by cylinder instead. Check out the function `aggregate()`.

```{r,accordion=TRUE}
aggregate(mtcars2$random1, by=list(mtcars$cyl), FUN=mean)
```

# Lists

The last data structure that we will explore are lists, which is a very flexible structure. Lists can combine different data structures and they do not have to be of equal dimensions or have
other restrictions. The drawback with a flexible structure is that it requires a bit more work to interact with.

The syntax to create a list is similar to creation of the other data structures in R.

```{r}
l <- list(1, 2, 3)
```

As with the data frames the `str()` command is very useful for the sometimes fairly complex lists instances.

```{r}
str(l)
```

This example containing only numeric vector is not very exciting example given the flexibility a list structure offers so let's create a more complex example.

```{r}
vec1 <- letters
vec2 <- 1:4
mat1 <- matrix(1:100, nrow = 5)
df1 <- as.data.frame(cbind(10:1, 91:100))
u.2 <- list(vec1, vec2, mat1, df1, l)
```

As you can see a list can not only contain other data structures, but can also contain other lists.

Looking at the `str()` command reveals much of the details of a list

```{r}
str(u.2)
```

With this more complex object, subsetting is slightly trickier than with more the more homogenous objects we have looked at so far.

To look at the first entry of a list one can use the same syntax as for the simpler structures, but note that this will give you a list of length 1 irrespective of the actual type of data structure found.

```{r}
u.2[1]
str(u.2[1])
```

If one instead wants to extract the list entry as the structure that is stored, one needs to "dig" deeper in the object.

```{r}
u.2[[1]]
str(u.2[[1]])
```

This means that the syntax to extract a specific value from a data structure stored in a list can be daunting. Below we extract the second column of a dataframe stored at position 4 in
the list **u.2**.  

```{r}
u.2[[4]][,2]
```

## Exercise

1. Create a list containing 1 character vector, a numeric vector, a character matrix.

```{r,accordion=TRUE}
list.2 <- list(vec1 = c("hi", "ho", "merry", "christmas"),
               vec2 = 4:19,
               mat1 = matrix(as.character(100:81),nrow = 4))
list.2
```

2. Here is a dataframe.

```{r}
dfr <- data.frame(letters, LETTERS, letters == LETTERS)
```

Add this dataframe to the list created above.

```{r,accordion=TRUE}
list.2[[4]] <- dfr
```

3. Remove the the second entry in your list.

```{r,accordion=TRUE}
list.2[-2]
```

4. Create a new list that contain 20 sublists, with each entry holding a numeric vector.

```{r,accordion=TRUE}
vec1 <- rnorm(1000)
list.a <- split(vec1, 1:20)
```

5. How long is your list, and how long are each of the vectors that are part of the list?

```{r,accordion=TRUE}
length(list.a)
lapply(list.a, FUN = "length")
```

6. Figure out what the main differences are between the function `lapply()` and `sapply` are and use both of them with the function summary on your newly created list. What are the pros and cons of the two approaches to calculate the same summary statistics?

```{r,accordion=TRUE}
lapply(X = list.a, FUN = "summary")
sapply(X = list.a, FUN = "summary")
```

# Extras

1. Design a S3 class that should hold information on human proteins. The data needed for each protein is:

- The gene that encodes it
- The molecular weight of the protein
- The length of the protein sequence
- Information on who and when it was discovered
- Protein assay data

Create this hypothetical S3 object in R.

2. Among the test data sets that are part of base R, there is one called **iris**. It contains measurements on set of plants. You can access the data using by typing `iris` in R. Explore this data set and calculate some useful summary statistics, like SD, mean and median for the parts of the data where this makes sense. Calculate the same statistics for any grouping that you can find in the data.

<!--chapter:end:lab_dataframes.Rmd-->

---
title: "Data Type"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

<br>

```{r,child="assets/header-lab.Rmd"}
```

# Introduction

There are different data modes used in R. The mode of a variable will
for example determine what kind of operators that can be done on it. At the end of
this exercise you should know:

-   What are the data types commonly used in R and how to create them
-   Use some basic operators in R
-   Understand how R coerces data if needed
-   Basic text manipulations

## Data types

From the lecture you might remember that all elements in any data stuctures found in R will be of a certain type (or have a certain mode). The four most commonly used data types in R are: logical, integer, double (often called numeric), and character. The names hints at what they are.

- Logical = TRUE or FALSE (or NA)
- Integer = Numbers that can be represented without fractional component
- Numeric = Any number that is not a complex number.
- Character = Text

In many cases the mode of on entry is determined by the content so if you save the value 5.1 as a variable in R, the variable will automatically be recognised as numeric. If you instead have a text string like "hello world" it will have the mode character. Below you will also see examples of how you can specify the mode and not rely on R inferring the right mode based on content.

# Exercises

<div class="boxy boxy-lightbulb">
In all exercises during this course, it is important that you try to figure out what the expected result would be, prior to running the commands. You should then verify that this will indeed be the
result by running the command. In case there is a discrepency between your expectations and the actual output make sure you understand why before you move forward. If you cannot figure out
how to, or which command to run you can click the key to reveal example code including expected output. If you are trying out things on your own have a hard time understanding what is going on, ask the TAs or your someone sitting next to you who might have wrapped their head around the issue.

Also note that in many cases there multiple solutions that solve the problem equally well.

We do recommend to write all code in a Rmarkdown document in R-studio as that will at the end of the course be your own R tutorial with comments and code solutions.
</div>

## Working with variables

Open Rstudio and make sure to set your working directory. Double check that you do not have stored objects in your current session with the following command. This will list all objects that you have in
your current R session.

```{r}
ls()
```

In case you have objects that you want to remove from the current session you can do so with the `rm()` function. <i class="fas fa-exclamation-circle"></i> This command will remove all objects available in your current environment.

```{r,eval=FALSE}
rm(list = ls())
```

This command uses commands that we have not talked about yet. If you do not understand how it works now, you will do so after tomorrows lectures and exercises.

1. Create variables *var1* and *var2* and initialize them with two integers of choice.

```{r,accordion=TRUE}
var1 <- 11
var2 <- 34
```

2. Add the two variables and save them as a new variable named *var3* and print the result.

```{r,accordion=TRUE}
var3 <- var1 + var2
var3
```

3. Check the class, mode, and type for var1, var2, var3 and &pi; (is found under the variable name `pi` in R)

```{r,accordion=TRUE}
mode(var1)
class(var1)
typeof(var1)
```

```{r,accordion=TRUE}
mode(pi)
class(pi)
typeof(pi)
```

4. Create two character variables containing a text of choice. Check the mode, class, and type of the first one.

```{r,accordion=TRUE}
text1 <- "test1"
text2 <- "test2"

mode(text1)
class(text1)
typeof(text1)
```

Add **var1** to it. What is the result and why?

```{r,accordion=TRUE,error=TRUE}
text1+var1
```

5. Convert **var3** to an integer, cast an integer variable to double, cast a string to a double.

```{r,accordion=TRUE}
as.integer(var3)
i <- 175
as.double(i)
as.double(text1)
```

6. Report floor and ceiling of &pi; and round &pi; to 3 decimal places.

```{r,accordion=TRUE}
floor(pi)
ceiling(pi)
round(pi, digits=3)
```

7. Is floor of &pi; an integer?

```{r,accordion=TRUE}
is.integer(floor(pi))
```

8. Treat `"3.56437"` string as number.

```{r,accordion=TRUE}
as.numeric('3.56437')
```

9. Divide &infin; by - &infin;

```{r,accordion=TRUE}
Inf/-Inf
```

10. Create two freely chosen complex numbers.

- Check that they are complex indeed.
- Add, multiply and divide one by another.
- Add an integer to their sum.

```{r,accordion=TRUE}
c1 <- 23 + 4i
c2 <- -15 - 7i
is.complex(c1)
is.complex(c2)
c1 + c2
c1 / c2
c1 + c2 + 7
```

11. Print a truth table for OR (for three distinct logical values). Read about truth tables [here](https://en.wikipedia.org/wiki/Truth_table).

```{r,accordion=TRUE}
x <- c(NA, FALSE, TRUE)
names(x) <- as.character(x)
outer(x, x, "|")
```

12. Multiply a logical TRUE by a logical FALSE. Rise the logical true to the 7-th power.

```{r,accordion=TRUE}
TRUE * FALSE
T^7
```

13. Create two character variables containing two verses of your favorite song.

- Concatenate the two variables,  
- Paste the variables with '\*' as separator.  
- Find if 'and' occurs in the second line,  
- Substitute a word for another,  
- Extract substring starting at the 5th character and 5 characters long.  

```{r,accordion=TRUE}
line1 <- "Hello darkness my old friend"
line2 <- "I've come to talk to you again"
paste(line1, line2, sep = "")
paste(line1, line2, sep = "*")
grep('and', line2)
sub('Hello', 'Goodbye', line1)
substr(line1, 5, 5 + 5)
```

## R Environment

- Get help for the *t.test*, *table*, *locator* and *identify* functions,
- Check for all occurences of *fisher.test* in the docs,
- Which package contains the *plot.ecdf* function. What does it do?
- Find package 'reshape'-related questions on StackOverflow,
- Search on the internet on how to load an XML file into R,
- Install the 'cgmisc' package from GitHub,
- Look up the 'cgmisc' vignette,
- See all the demos available for you and run one you like,
- Run examples for the *fisher.test*,
- Check out CRANs view for genetics,
- Install a CRAN package of choice,
- Install the R-Forge package 'bigRR'

<!--chapter:end:lab_datatypes.Rmd-->

---
title: "R graphics using ggplot2"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

```{r,include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
```

# Introduction

Although the plotting capabilities of R base are really impressive compared to other programming languages, there are other packages available to help you generate awesome graphics. Two of the more popular packages besides the base package are **lattice** and **ggplot2**. According to many users, these are superior to
the base plot library, especially when it comes to exploratory data analysis; without too much work, they generate trellis graphics, e.g. graphs that display a variable or the relationship between variables, conditioned on one or more other variables. Over the last years ggplot2 has become the standard plotting library for many R users, especially as it keeps evolving and new features are added continuously. In addition to being more convient for certain types of plots, many feel that the default colors, axis types etc. look better on ggplot2 compared to the base R and lattice libraries.

# Basics

First step is to make sure that `ggplot2` is installed and the package is loaded.

```{r}
library(ggplot2)
```

We use the `iris` data to get started. This dataset has four continuous variables and one categorical variable. It is important to remember about the data type when plotting graphs. 

```{r}
data("iris")
head(iris)
```

## Building a plot

ggplot2 plots are initialised by specifying the dataset. This can be saved to a variable or it draws a blank plot.

```{r,fig.height=4,fig.width=4}
ggplot(data=iris)
```

Now we can specify what we want on the x and y axes using aethetic mapping. And we specify the geometric using geoms. Note that the variable names do not have double quotes `""` like in base plots.

```{r,fig.height=4,fig.width=4}
ggplot(data=iris)+
  geom_point(mapping=aes(x=Petal.Length,y=Petal.Width))
```

## Multiple geoms

Further geoms can be added. For example let's add a regression line. When multiple geoms with the same aesthetics are used, they can be specified as a common mapping. Note that the order in which geoms are plotted depends on the order in which the geoms are supplied in the code. In the code below, the points are plotted first and then the regression line. 

```{r,fig.height=4,fig.width=4}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point()+
  geom_smooth(method="lm")
```

## Using colors

We can use the categorical column `Species` to color the points. The color aesthetic is used by `geom_point` and `geom_smooth`. Three different regression lines are now drawn. Notice that a legend is automatically created.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width,color=Species))+
  geom_point()+
  geom_smooth(method="lm")
```

If we wanted to keep a common regression line while keeping the colors for the points, we could specify color aesthetic only for `geom_point`.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species))+
  geom_smooth(method="lm")
```

## Aesthetic parameter

We can change the size of all points by a fixed amount by specifying size outside the aesthetic parameter.
 
```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species),size=3)+
  geom_smooth(method="lm")
```

## Aesthetic mapping

We can map another variable as size of the points. This is done by specifying size inside the aesthetic mapping. Now the size of the points denote `Sepal.Width`. A new legend group is created to show this new aesthetic.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))+
  geom_smooth(method="lm")
```

## Discrete colors

We can change the default colors by specifying new values inside a scale.
 
```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_manual(values=c("red","blue","green"))
```

## Continuous colors

We can also map the colors to a continuous variable. This creates a color bar legend item.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")
```

## Titles

Now let's rename the axis labels, change the legend title and add a title, a subtitle and a caption. We change the legend title using `scale_color_continuous()`. All other labels are changed using `labs()`.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")
```

## Axes modification

Let's say we are not happy with the x-axis breaks 2,4,6 etc. We would like to have 1,2,3... We change this using `scale_x_continuous()`.

```{r,fig.height=4,fig.width=5}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  scale_x_continuous(breaks=1:8)+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")
```

## Facetting

We can create subplots using the facetting functionality. Let's create three subplots for the three levels of Species.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  scale_x_continuous(breaks=1:8)+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")+
  facet_wrap(~Species)
```

## Themes

The look of the plot can be changed using themes. Let's can the default `theme_grey()` to `theme_bw()`.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  scale_x_continuous(breaks=1:8)+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")+
  facet_wrap(~Species)+
  theme_bw()
```

All non-data related aspects of the plot can be modified through themes. Let's modify the colors of the title labels and turn off the gridlines. The various parameters for theme ca be found using `?theme`.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  scale_x_continuous(breaks=1:8)+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")+
  facet_wrap(~Species)+
  theme_bw()+
  theme(
    axis.title=element_text(color="Blue",face="bold"),
    plot.title=element_text(color="Green",face="bold"),
    plot.subtitle=element_text(color="Pink"),
    panel.grid=element_blank()
  )
```

Themes can be saved and reused.

```{r,fig.height=4,fig.width=6,dev="png"}
newtheme <- theme(
    axis.title=element_text(color="Blue",face="bold"),
    plot.title=element_text(color="Green",face="bold"),
    plot.subtitle=element_text(color="Pink"),
    panel.grid=element_blank())

ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Sepal.Width))+
  geom_smooth(method="lm")+
  scale_color_continuous(name="New Legend Title")+
  scale_x_continuous(breaks=1:8)+
  labs(title="This Is A Title",subtitle="This is a subtitle",x=" Petal Length", 
       y="Petal Width", caption="This is a little caption.")+
  facet_wrap(~Species)+
  theme_bw()+
  newtheme

```

## Controlling legends

Here we see two legends based on the two aesthetic mappings.

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))
```

If we don't want to have the extra legend, we can turn off legends individually by aesthetic.

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))+
  guides(size="none")
```

We can also turn off legends by geom.

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width),show.legend=FALSE)
```

Legends can be moved around using theme.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))+
  theme(legend.position="top",
        legend.justification="right")
```

Legend rows can be controlled in a finer manner.

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species,size=Sepal.Width))+
  guides(size=guide_legend(nrow=2,byrow=TRUE),
         color=guide_legend(nrow=3,byrow=T))+
  theme(legend.position="top",
        legend.justification="right")
```

## Labelling

Items on the plot can be labelled using the `geom_text` or `geom_label` geoms.

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species))+
  geom_text(aes(label=Species,hjust=0),nudge_x=0.5,size=3)
```

```{r,fig.height=4,fig.width=5,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species))+
  geom_label(aes(label=Species,hjust=0),nudge_x=0.5,size=3)
```

Check out the R package `ggrepel` allows for non-overlapping labels.

## Annotations

Custom annotations of any geom can be added arbitrarily anywhere on the plot.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Petal.Length,y=Petal.Width))+
  geom_point(aes(color=Species))+
  annotate("text",x=2.5,y=2.1,label="There is a random line here")+
  annotate("segment",x=2,xend=4,y=1.5,yend=2)
```

## Barplots

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Species,y=Petal.Width))+
  geom_bar(stat="identity")
```

## Flip axes

x and y axes can be flipped using `coord_flip`.

```{r,fig.height=4,fig.width=6,dev="png"}
ggplot(data=iris,mapping=aes(x=Species,y=Petal.Width))+
  geom_bar(stat="identity")+
  coord_flip()
```

## Error Bars

An example of using error bars with points. The mean and standard deviation is computed. This is used to create upper and lower bounds for the error bars.

```{r,fig.height=4,fig.width=6}
dfr <- iris %>% group_by(Species) %>% 
  summarise(mean=mean(Sepal.Length),sd=sd(Sepal.Length)) %>%
  mutate(high=mean+sd,low=mean-sd)

ggplot(data=dfr,mapping=aes(x=Species,y=mean,color=Species))+
  geom_point(size=4)+
  geom_errorbar(aes(ymax=high,ymin=low),width=0.2)
```

# Covid data

Covid cases data was download from [ECDC](https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide) as a CSV file. We will explore this dataset to plot some common scientific figures.

Read the table, keep only date up to september, convert the `dateRep` as date format to a new column named `date`, convert month and year to factors.

```{r}
d <- read.csv("https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_ggplot2/covid.csv",header=TRUE,stringsAsFactors=TRUE) %>%
  filter(month<=9) %>%
  mutate(date=as.Date(as.character(dateRep),"%d/%m/%Y"),
         month=as.factor(month),
         year=as.factor(year)) 
```

## Histogram

Create a histogram showing the overall distribution of cases.

```{r,class.source="blur-effect"}
d %>%
  ggplot(aes(x=cases))+
  geom_histogram()
```

A whole lot of zero cases which is not surprising. A very few number of extremely large number of cases. 

## Line plot

A line plot is a good option when you dense data and over a time period/duration. Create a line plot for the Country Sweden (`geoId=="SE"` or `countriesAndTerritories=="Sweden"`) showing date (`date`) on the x-axis and cases per day (`cases`) on the y-axis. Set a plot title and axes titles.

```{r,class.source="blur-effect"}
d %>% 
  filter(geoId=="SE") %>%
  ggplot(aes(x=date,y=cases))+
  geom_line()+
  labs(x="Date",y="Cases",title="Sweden | COVID Cases Per Day")
```

The number of cases per day in Sweden are shown for the period from Jan to Sep. The highest peak is in June and cases were low in summer. Why do you think the line is oscillating up and down rather than being a smooth line?

Similar to above, create a line plot for the following 8 countries: `Sweden, Denmark, Norway, Finland, United_Kingdom, France, Germany, Italy` where each country has a different coloured line. Set plot title and axes titles. Change theme to `theme_bw()`.

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=date,y=cases,colour=countriesAndTerritories))+
  geom_line()+
  scale_color_discrete(name="Country")+
  labs(x="Date",y="Cases",title="COVID Cases Per Day")+
  theme_bw()
```

The countries with lower number of counts are hard to see. Perhaps a log transformation would help? Change the y-axis to a log scale to bring clarity to countries with lower cases.

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=date,y=cases,colour=countriesAndTerritories))+
  geom_line()+
  scale_y_log10()+
  scale_color_discrete(name="Country")+
  labs(x="Date",y="Cases",title="COVID Cases Per Day")+
  theme_bw()
```

Did that really help? Why not? Perhaps we could draw a trendline rather than showing the actual data. Create a line plot for the same information as above showing a smoothed trendline (`geom_smooth()`) rather than the actual data points.

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=date,y=cases,colour=countriesAndTerritories))+
  geom_smooth()+
  scale_y_log10()+
  scale_color_discrete(name="Country")+
  labs(x="Date",y="Cases",title="COVID Cases Per Day")+
  theme_bw()
```

This is much easier to read.

Similarily, we can plot regression lines by changing arguments inside `geom_smooth()`.

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=date,y=cases,colour=countriesAndTerritories))+
  geom_smooth(method="lm")+
  scale_y_log10()+
  scale_color_discrete(name="Country")+
  labs(x="Date",y="Cases",title="COVID Cases Per Day")+
  theme_bw()
```

## Boxplots

Boxplot show the full distribution of data within a bin. Now, for the same countries, create monthwise boxplots (`geom_boxplot()`) of cases.

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=month,y=cases,colour=countriesAndTerritories))+
  geom_boxplot()+
  #facet_wrap(~countriesAndTerritories)+
  scale_color_discrete(name="Country")+
  labs(x="Month",y="Cases",title="COVID Cases Per Month")+
  theme_bw()
```

This gets a bit messy. Can you split each country into a subplot rather than showing all the countries in one plot?

```{r,class.source="blur-effect"}
d %>%
  filter(countriesAndTerritories %in% c("Sweden", "Denmark", "Norway", "Finland", "United_Kingdom", "France", "Germany", "Italy")) %>%
  ggplot(aes(x=month,y=cases,colour=countriesAndTerritories))+
  geom_boxplot()+
  facet_wrap(~countriesAndTerritories)+
  scale_color_discrete(name="Country")+
  labs(x="Month",y="Cases",title="COVID Cases Per Month")+
  theme_bw()
```

## Barplots

Create a barplot (`geom_bar()`) with mean cases for each continent.

```{r,class.source="blur-effect"}
d %>%
  group_by(continentExp) %>%
  summarise(mean=mean(cases,na.rm=TRUE)) %>%
  ggplot(aes(x=continentExp,y=mean))+
  geom_bar(stat="identity")
```

Now for a bit more complexity, create a stacked barplot (`geom_bar()`) with total cases monthwise for each continent. Set months on the x-axis, cases on the y-axis. Colour the bars by continent.

```{r,class.source="blur-effect"}
d %>%
  group_by(continentExp,month) %>%
  summarise(sum=sum(cases,na.rm=TRUE)) %>%
  ggplot(aes(x=month,y=sum,fill=continentExp))+
  geom_bar(stat="identity")
```

This figure shows the total number of cases per month across the globe. Continent-wise information shows that a large proportion of the cases are in America followed by Asia. The more common usage of stacked barplots is to show proportion/percentage rather than absolute counts (ie; all the bars are same height).

Create a stacked barplot as above showing proportion of total cases on the y-axis.

```{r,class.source="blur-effect"}
d %>%
  group_by(continentExp,month) %>%
  summarise(sum=sum(cases,na.rm=TRUE)) %>%
  ungroup() %>%
  group_by(month) %>%
  mutate(total=sum(sum,na.rm=TRUE)) %>%
  ungroup() %>%
  mutate(frac=round(sum/total,5)) %>%
  ggplot(aes(x=month,y=frac,fill=continentExp))+
  geom_bar(stat="identity")+
  scale_fill_discrete(name="Continent")+
  theme_bw()+
  labs(x="Month",y="Proportion of Cases")
```

Now, we can see that the pandemic initially started with 100% of the cases in the Asia. As we can also see the rise and fall of cases over summer.

Now let's look at barplots with error bars. First, create a barplot showing mean number of cases per continent per month. Place the bars within a group (month) next to each other rather than stack.

```{r,class.source="blur-effect"}
d %>%
  group_by(continentExp,month) %>%
  summarise(mean=mean(cases,na.rm=TRUE)) %>%
  ggplot(aes(x=month,y=mean,fill=continentExp))+
  geom_bar(stat="identity",position=position_dodge())+
  scale_fill_discrete(name="Continent")+
  labs(x="Month",y="Mean cases per Month")
```

Now to compute, error bars, computer error metrics in the `summary()` function, let's say standard deviation (`sd()`).

```{r,class.source="blur-effect"}
d %>%
  group_by(continentExp,month) %>%
  summarise(mean=mean(cases,na.rm=TRUE),
            sd=sd(cases,na.rm=TRUE),
            high=mean+sd,
            low=mean-sd) %>%
  ggplot(aes(x=month,y=mean,fill=continentExp))+
  geom_bar(stat="identity",position=position_dodge())+
  geom_errorbar(aes(ymax=high,ymin=low),position=position_dodge(width=0.9),colour="grey40")+
  scale_fill_discrete(name="Continent")+
  labs(x="Month",y="Mean cases per Month")
```

## Scatterplots

Scatterplots are commonly used for continuous vs continuous variables. Let's try to see if there is any relationship between number of cases and number of deaths. Create a scatterplot showing `cases` vs `deaths`.

```{r,class.source="blur-effect",dev="png"}
ggplot(d,aes(cases,deaths))+
  geom_point()
```

Scatterplots are extremely useful in visually inspecting relationships between variables.

Scatterplots can also be used with categorical variables. Create a scatterplot with month on the x-axis and cases per month on the y-axis. Colour the points by continent.

```{r,class.source="blur-effect",dev="png"}
ggplot(d,aes(x=month,y=cases,colour=continentExp))+
  geom_point()+
  scale_colour_discrete(name="Continent")+
  labs(x="Month",y="Cases per Month")
```

`geom_jitter()` can be used to jitter the points around, so they do not overlap.

```{r,class.source="blur-effect",dev="png"}
ggplot(d,aes(x=month,y=cases,colour=continentExp))+
  geom_jitter(width=0.3)+
  scale_colour_discrete(name="Continent")+
  labs(x="Month",y="Cases per Month")
```

Create a scatterplot with month on the x-axis and **mean** cases per month on the y-axis. Colour the points by continent.

```{r,class.source="blur-effect",dev="png"}
d %>%
  group_by(month,continentExp) %>%
  summarise(mean=mean(cases,na.rm=TRUE)) %>%
  ggplot(aes(x=month,y=mean,colour=continentExp))+
  geom_point()+
  scale_colour_discrete(name="Continent")+
  labs(x="Month",y="Mean cases per Month")
```

Add a line to connect the continents across months. Use the `group` argument in `aes()`.

```{r,class.source="blur-effect",dev="png"}
d %>%
  group_by(month,continentExp) %>%
  summarise(mean=mean(cases,na.rm=TRUE)) %>%
  ggplot(aes(x=month,y=mean,colour=continentExp,group=continentExp))+
  geom_point()+
  geom_line()+
  scale_colour_discrete(name="Continent")+
  labs(x="Month",y="Mean cases per Month")
```

Now for a slightly more advanced example. Create the same plot above with each continent as separate facets. Add all other continents in the background as reference lines in light grey colour.

```{r,class.source="blur-effect",fig.height=6,dev="png"}
ds <- d %>%
  group_by(month,continentExp) %>%
  summarise(mean=mean(cases,na.rm=TRUE))

# new df for background points
dsb <- ds %>% mutate(co=continentExp) %>% select(-continentExp)

ggplot()+
  geom_point(data=dsb,aes(x=month,y=mean,group=co),colour="grey90")+
  geom_line(data=dsb,aes(x=month,y=mean,group=co),colour="grey90")+
  geom_point(data=ds,aes(x=month,y=mean,colour=continentExp,group=continentExp))+
  geom_line(data=ds,aes(x=month,y=mean,colour=continentExp,group=continentExp))+
  facet_wrap(~continentExp)+
  scale_colour_discrete(name="Continent")+
  labs(x="Month",y="Mean cases per Month")+
  guides(colour=guide_legend(nrow=1))+
  theme_bw()+
  theme(plot.background = element_blank(),
        panel.border = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major.x = element_blank(),
        legend.position = "top",
        legend.direction = "horizontal",
        legend.title=element_blank(),
        strip.background = element_blank())
```

## Heatmap

Here, we will look at creating a heatmap using ggplot2 as well as fine customisation of the plot for publication. This heatmap shows cases for all European countries over time. This is also a slightly more advanced example.

First, countries in Europe are selected and cases per million people is computed.

```{r,fig.height=8}
# subset europe, calculate cases per million
d2 <- d %>%
  filter(continentExp=="Europe") %>%
  mutate(casesp=log10(round((cases/popData2019)*10^6,3)+1))
```

```{r,fig.height=8,dev="png"}
# colours
cols <- c("#e7f0fa","#c9e2f6","#95cbee","#0099dc","#4ab04a", "#ffd73e","#eec73a","#e29421","#f05336","#ce472e")
leg_label <- "Log[10]~Cases~Per~Million~Persons"

# plotting
ggplot(d2,aes(x=date,y=countriesAndTerritories,fill=casesp))+
  geom_tile()+
  labs(x="",y="")+
  scale_fill_gradientn(colors=cols,na.value="grey90",
   guide=guide_colourbar(ticks=T,nbin=10,barheight=.5,label=T,barwidth=10),
   name=eval(parse(text=leg_label)))+
  scale_x_date(breaks=seq(as.Date("2020/1/1"), by = "month", length.out = 10),
               labels=format(seq(as.Date("2020/1/1"), by = "month", length.out = 10),"%b"))+
  theme_bw()+
  theme(plot.background = element_blank(),
        panel.border = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        legend.position = "top",
        legend.direction = "horizontal")
#pheatmap::pheatmap(d3,cluster_cols = F,scale = "none")
```

It would be nice to have the countries grouping together based on the trend rather than just alphabetical order. This bit of code below clusters countries based on the data. Therefore, countries with similar case patterns should cluster together.

```{r}
# cluster countries
d3 <- d2 %>%
  mutate(casesp=casesp) %>%
  select(date,countriesAndTerritories,casesp) %>%
  spread(key=date,value=casesp)
rownames(d3) <- d3$countriesAndTerritories
d3$countriesAndTerritories <- NULL
h <- hclust(dist(d3))
d2$countriesAndTerritories <- factor(as.character(d2$countriesAndTerritories),levels=rownames(d3)[h$order])
```

```{r,include=FALSE}
#h <- hclust(as.dist(cor(t(d3),use = "na.or.complete")))
```

Now, our new figure looks like this. It should be easier to see the trend over time. Primary and secondary waves are now starting to be easily visible.

```{r,fig.height=8,dev="png"}
# colours
cols <- c("#e7f0fa","#c9e2f6","#95cbee","#0099dc","#4ab04a", "#ffd73e","#eec73a","#e29421","#f05336","#ce472e")
leg_label <- "Log[10]~Cases~Per~Million~Persons"

# plotting
ggplot(d2,aes(x=date,y=countriesAndTerritories,fill=casesp))+
  geom_tile()+
  labs(x="",y="")+
  scale_fill_gradientn(colors=cols,na.value="grey90",
   guide=guide_colourbar(ticks=T,nbin=10,barheight=.5,label=T,barwidth=10),
   name=eval(parse(text=leg_label)))+
  scale_x_date(breaks=seq(as.Date("2020/1/1"), by = "month", length.out = 10),
               labels=format(seq(as.Date("2020/1/1"), by = "month", length.out = 10),"%b"))+
  theme_bw()+
  theme(plot.background = element_blank(),
        panel.border = element_blank(),
        axis.ticks = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        legend.position = "top",
        legend.direction = "horizontal")
```


<!--chapter:end:lab_ggplot2.Rmd-->

---
title: "Graphics in R"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

```{r,include=FALSE}
library(lubridate)
```

# Introduction

In this lab, we will go step-by-step through manually building a scientific plot using base graphics in R.

# Generating data

First, we will produce some random data that we will later plot. Make a data frame with

- 20 random coordinates (x,y) and
- radius $r$ for each data point.
- The *x* coord takes random values from 1 to 25 and
- both the *y* and the radius *r* coord are samples from $N(0,1)$.
- Each point (row of the data frame) has a name *ind1 ... ind25*.

First, look at the defaults:

- plot the data in the simplest possible way.

```{r,fig.height=6,fig.width=10}
#20 random datapoints
x <- sample(c(1:25), size=20, replace=T)
y <- rnorm(n=20, mean=0, sd=1) # sample from normal
r <- rnorm(n=20, mean=0, sd=1) # radius from normal
names <- paste("ind", 1:20, sep="") # assign some names
data <- data.frame(cbind(X=x,Y=y, R=r), row.names=names)
plot(data[,1:2])
```

# Building a plot

As you see, the points are displayed in a simple way, axes are set automatically, the radius is not reflected on the plot in any way (3rd dimension).

## Hide markers

Build the plot from scratch, begin by displaying no points. You can do this by setting `type = 'n'`.   

* Other `type`s:   
  + "p" for points.   
  + "l" for lines.   
  + "b" for both points and lines.  
  + "c" for empty points joined by lines.  
  + "o" for overplotted points and lines.  
  + "s" and "S" for stair steps.   
  + "h" for histogram-like vertical lines.   
  + "n" does not produce any points or lines.   
  

```{r,fig.height=6,fig.width=10}
plot(data[,1:2], type='n')
```

## Hide border/axes

Remove the default box around the plot and axes.

```{r,fig.height=6,fig.width=10}
plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)
```

## Axes labels

Create X and Y axis so that they cover the whole range of *x* and *y*. For the Y axis, set 10 equidistant tickmarks and set labels to their values rounded to two decimals. Turn the labels, so that they are parallel to the OX axis.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##
plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)
```

```{r,eval=FALSE}
#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)
```

## Grid lines

Plot gridlines so that it is easier to read the plot. There should be a grey dashed line from each tickmark on both axes.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)
#you could also use grid()
```

## Add markers

Define a new *mycol* function that takes a color name and a transparency value as two arguments and returns the corresponding rgb color value. 
  
```{r,fig.height=6,fig.width=10}
#Function for adding transparency to a given color.
mycol <- function(colname="olivedrab", transparency=.5) {
#convert color name to its RGB value and add the desired
#transparency
color <- c(as.vector(col2rgb(colname))/255, transparency)
# and make a new color from the above
color <- rgb(color[1], color[2], color[3], color[4])
return(color)
}
```

Plot datapoints so that their size is proportional to $e^r$ where $r$ is the radius, points at even X should be round and blue and points at odd X square and grey.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)

points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
#Plot radii
points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))
```

Plot centers of the points as a cross: grey for blue/even points and red for grey/odd points.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)

points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))

points(data[data$X%%2 == 0,], pch=3, cex=1, col="darkgrey")
points(data[data$X%%2 != 0,], pch=3, cex=1, col="red")
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
points(data[data$X%%2 == 0,], pch=3, cex=1, col="darkgrey")
points(data[data$X%%2 != 0,], pch=3, cex=1, col="red")
```

## Annotation

Add grey text 'Center' at the center of the plot.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)

points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))

points(data[data$X%%2 == 0,], pch=3, cex=1, col="darkgrey")
points(data[data$X%%2 != 0,], pch=3, cex=1, col="red")

center.x <- mean(range(data[,1]))
center.y <- mean(range(data[,2]))
text(x=center.x, y=center.y, "Center", col="lightgrey")
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
center.x <- mean(range(data[,1]))
center.y <- mean(range(data[,2]))
text(x=center.x, y=center.y, "Center", col="lightgrey")
```

## Titles

Add title 'Odds and Ends' and text 'X' and 'Y' on the margins of the appropriate axes.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)

points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))

points(data[data$X%%2 == 0,], pch=3, cex=1, col="darkgrey")
points(data[data$X%%2 != 0,], pch=3, cex=1, col="red")

center.x <- mean(range(data[,1]))
center.y <- mean(range(data[,2]))
text(x=center.x, y=center.y, "Center", col="lightgrey")

title("Odds and Ends")
mtext("Y", side=2, line=3, cex.lab=1,las=2, col="blue")
mtext("X", side=1, line=3, cex.lab=1,las=1, col="blue")
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
title("Odds and Ends")
mtext("Y", side=2, line=3, cex.lab=1,las=2, col="blue")
mtext("X", side=1, line=3, cex.lab=1,las=1, col="blue")
```

## Legend

Add a legend for 'odd' and 'even' points. Place it in the top-right corner.

```{r,fig.height=6,fig.width=10,echo=FALSE}
## CODE EVALUATED BUT HIDDEN FROM OUTPUT ##

plot(data[,1:2], type='n',xaxt='n', yaxt='n',xlab="", ylab="", frame.plot=F)

#Create X axis
coords.x <- seq(min(data$X),max(data$X), by=1)
axis(side=1, # 1-left, 2-top, 3-right, 4-bottom
  at=coords.x # coordinates for tickmarks
)

#Create Y axis
#we want 10 tickmarks along the data range
coords.y <- seq(min(data$Y), max(data$Y), length.out=10)

#and our labels will be the rounded values of y
labels.y <- round(coords.y, digits=2)
axis(side=2,
  at=coords.y,
  labels=labels.y, # we want specific labels
  las=2 # turn the text so it is parallel to OX
)

abline(v=coords.x, col="darkgrey", lty=3)
abline(h=coords.y, col="darkgrey", lty=3)

points(data[data$X%%2 == 0,], pch=19, cex=exp(r), col=mycol("slateblue", .5))
points(data[data$X%%2 != 0,], pch=15, cex=exp(r), col=mycol("grey", .5))

points(data[data$X%%2 == 0,], pch=3, cex=1, col="darkgrey")
points(data[data$X%%2 != 0,], pch=3, cex=1, col="red")

center.x <- mean(range(data[,1]))
center.y <- mean(range(data[,2]))
text(x=center.x, y=center.y, "Center", col="lightgrey")

title("Odds and Ends")
mtext("Y", side=2, line=3, cex.lab=1,las=2, col="blue")
mtext("X", side=1, line=3, cex.lab=1,las=1, col="blue")

legend('topright',
	legend=c("odd", "even"),
	col=c(mycol("slateblue", .5), mycol("grey", .5)),
	pch=c(19,15),
	cex=1,
	pt.cex=1.2,
	title="Legend",
	bty='n'
)
```

```{r,fig.height=6,fig.width=10,eval=FALSE}
legend('topright',
	legend=c("odd", "even"),
	col=c(mycol("slateblue", .5), mycol("grey", .5)),
	pch=c(19,15),
	cex=1,
	pt.cex=1.2,
	title="Legend",
	bty='n'
)
```

# Visualizing growth data

A female child was measured at the following dates:

- '30-09-2015', '12-10-2015', '19-10-2015', '26-10-2015', '07-11-2015', '16-11-2015', '30-11-2015', '11-01-2016', '08-02-2016', '14-03-2016', '05-04-2016', '14-04-2016', '31-05-2016', '14-07-2016',

- the measured weights in grams were: 3300, 3540, 3895, 4070, 4230, 4385, 4855, 5865, not taken, 6736, 7065, 7080, 7530, 7640 and
- the measured lengths: 43, no measurement taken, 53, 54, 55, 56, 58, 62.5, 65, 67, 67.5, 67.5, 70.5, 71.5.
- The headcircumference for the same datapoints was (in cm): 34, 35.5, 36.1, 36.8, 36.8, 37.3, 38, 40.2, 41.4, 42.1, not taken, 43, 44, 45.

Your task is to plot these data on the WHO centile grids. Choose weight/length/circumference depending on the month you was born:

  - weight: Jan, Apr, Jul, Oct
  - length: Feb, May, Aug, Nov
  - circumference: Mar, Jun, Sep, Dec

## Prepare input data

We save the timepoints and measurements in vectors.  
```{r}
library(lubridate)
timepoints <- dmy(c('30-09-2015', '12-10-2015','19-10-2015', '26-10-2015', '07-11-2015', '16-11-2015','30-11-2015', '11-01-2016', '08-02-2016', '14-03-2016', '05-04-2016', '14-04-2016', '31-05-2016', '14-07-2016'))

weight <- c(3300, 3540, 3895, 4070, 4230, 4385, 4855, 5865, NA, 6736, 7065, 7080, 7530, 7640)
length <- c(43,NA,53,54,55,56,58,62.5,65,67,67.5,67.5,70.5,71.5)
head <- c(34,35.5,36.1,36.8,36.8,37.3,38,40.2,41.4,42.1,NA,43,44,45)
```

We can calculate the interval between the dates of measurements by two approaches:  
**Approach1:**  
Simply calculate the interval by subtracting each date from the the first date of data collection (e.g. '2016-05-31' - '2015-09-30' )  and then convert it to months.  

```{r}
xpoints <- (as.Date(timepoints) - as.Date(timepoints[1]) )/ 30
```

**Approach2:**  
Calculate the intervals by seconds and then use WHO standard months day length which is 30.4375 to calculate by month.   
Use function `dmy()` from the **lubridate** package to create a vector of timepoints.

HINTS:   
- We can define an Interval using the `%--%` operator.  
- check `as.duration()` and `ddays()` functions.  



```{r, echo = T, eval = F}
who.month <- 30.4375 #days
xpoints <- as.duration(timepoints[1] %--% timepoints) / ddays(1) / who.month
```

## Prepare reference data

Download manually and then load:   
Go to WHO website (http://www.who.int/childgrowth/standards/en/) and find out the link to the dataset of your concern, e.g. Weight for age, percentiles for girls have the following address: http://www.who.int/entity/childgrowth/standards/wfa_girls_p_0_5.xlsx

Or using direct link to the excel file:  

```{r,eval=T}
library(readxl)
uri <- "https://cdn.who.int/media/docs/default-source/child-growth/child-growth-standards/indicators/weight-for-age/tab_wfa_girls_p_0_5.xlsx?sfvrsn=666fe445_7"
local_file_path <- "wfa_girls_p_0_5.xlsx" ## give the local path of the downloaded file
download.file(url = uri, destfile = local_file_path, mode = "wb")
myData <-read_excel(local_file_path)
```

## Build empty plot

Create an empty plot to show your and WHO data,

```{r,accordion=TRUE,fig.height=6,fig.width=10,eval=T}
plot(1, xlim=c(0, max(myData$Month)), type='n', bty='n', ylim=c(0, max(myData[,c(5:19)])), las=1, xlab='Month', ylab='kg')
grid()
```

## Plot reference data

Plot WHO mean and percentiles: P25, P75, P0.1 and P99.9, use different colors and line types to make the plot pretty.

```{r,fig.height=6,fig.width=10,echo=FALSE,eval=FALSE}
## CODE EVALUATED BUT NOT DISPLAYED ##

plot(1, xlim=c(0, max(myData$Month)), type='n', bty='n', ylim=c(0, max(myData[,c(5:19)])), las=1, xlab='Month', ylab='kg')
grid()

lines(myData$M, col='grey', lty=1)
lines(myData$P25, col='blue', lty=2)
lines(myData$P75, col='blue', lty=2)
lines(myData$P01, col='tomato', lty=2)
lines(myData$P999, col='tomato', lty=2)
```

```{r,accordion=TRUE,eval=FALSE}
lines(myData$M, col='grey', lty=1)
lines(myData$P25, col='blue', lty=2)
lines(myData$P75, col='blue', lty=2)
lines(myData$P01, col='tomato', lty=2)
lines(myData$P999, col='tomato', lty=2)
```

## Plot input data

Plot your data on top of the percentiles, mind the units so that they match with the WHO ones

```{r,fig.height=6,fig.width=10,echo=FALSE,eval=T}
## CODE EVALUATED BUT NOT DISPLAYED ##

plot(1, xlim=c(0, max(myData$Month)), type='n', bty='n', ylim=c(0, max(myData[,c(5:19)])), las=1, xlab='Month', ylab='kg')
grid()

lines(myData$M, col='grey', lty=1)
lines(myData$P25, col='blue', lty=2)
lines(myData$P75, col='blue', lty=2)
lines(myData$P01, col='tomato', lty=2)
lines(myData$P999, col='tomato', lty=2)

points(xpoints, weight/1000, pch=3, type='l', cex=.5)
points(xpoints, weight/1000, pch=3, type='p', cex=.5)
```

```{r,accordion=TRUE,eval=FALSE}
points(xpoints, weight/1000, pch=3, type='l', cex=.5)
points(xpoints, weight/1000, pch=3, type='p', cex=.5)
```

## Add annotation

Add descriptions of the confidence lines in the margins

```{r,fig.height=6,fig.width=10,echo=FALSE,eval=T}
## CODE EVALUATED BUT NOT DISPLAYED ##

plot(1, xlim=c(0, max(myData$Month)), type='n', bty='n', ylim=c(0, max(myData[,c(5:19)])), las=1, xlab='Month', ylab='kg')
grid()

lines(myData$M, col='grey', lty=1)
lines(myData$P25, col='blue', lty=2)
lines(myData$P75, col='blue', lty=2)
lines(myData$P01, col='tomato', lty=2)
lines(myData$P999, col='tomato', lty=2)

points(xpoints, weight/1000, pch=3, type='l', cex=.5)
points(xpoints, weight/1000, pch=3, type='p', cex=.5)

mtext(text = c('P0.1','P25','P75','P99.9'), side = 4, at=myData[dim(myData)[1], c('P01','P25','P75','P999')], las=1, cex=.8)
```

```{r,accordion=TRUE,eval=FALSE}
mtext(text = c('P0.1','P25','P75','P99.9'), side = 4, at=myData[dim(myData)[1], c('P01','P25','P75','P999')], las=1, cex=.8)
```

# Visualizing Gapminder data

You task here is to use the already acquired R knowledge to plot an interesting relationship between two freely selected variables available at Hans Rosling's Gapminder Foundation page.

- Go to http://www.gapminder.org/data/
- Select a dataset of interest,
- Load data to R, take care of missing values etc.,
- Find a nice way of visualizing the relationship between some selected variables,
- Think of scales (linear, logarythmic), axes labels etc.,
- Be creative,
- Visualize a selected variables using boxplot and histogram on one plot (HINT: parameter mfrow),
- Discuss the result with your colleagues and TAs.

<!--chapter:end:lab_graphics.Rmd-->

---
title: "Loading data into R"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

# Introduction

Up until now we have mostly created the object we worked with on the fly from within R. The most common use-case is however to read in different data sets that are stored as files, either somewhere on a server or locally on your computer. In this exercise we will test some common ways to import data in R and also show to save data from R. After this exercise you will know how to:

-   Read data from txt files and save the information as a vector, data frame or a list.
-   Identify missing data and correctly encode this at import
-   Check that imported objects are imported correctly
-   Read data from online resource
-   Write data to a file

# `scan()`

The function `scan()` can be used both to read data from files and directly from keyboard. The function is very flexible and have many different settings that allow to read data in different formats. To read and store a set of words that you type on your keyboard try the following code that will prompt your for input. After each word press enter and R will prompt you for new input. After the last word have been typed press enter twice to get back to your R prompt and have your character vector named words available in R your session.

```{r,eval=FALSE}
words <- scan(what=character())
```

We will read in this [book chapter](https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/book_chapter.txt). Read the manual for scan and read the text file named **book_chapter.txt** into R, first as vector and then as a list, with each word in the chapter saved as a entry in the vector or as a single vector in a list.


```{r,accordion=TRUE}
shelley.vec <- scan(file="https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/book_chapter.txt", what=character())
str(shelley.vec)

shelley.list <- scan(file="https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/book_chapter.txt", what=list(character()))
class(shelley.list)
```

Check that your newly created objects contain the correct information and have been saved as you have intended eg. each entry of the vector or the list should contain a single word. Once your convinced that you have a sound word vector and list.

1.  Identify the longest word in your vector.

```{r,accordion=TRUE}
sort(nchar(shelley.vec), decreasing=TRUE)
which(nchar(shelley.vec) == max(nchar(shelley.vec)))
shelley.vec[381]
```

2.  Go back and fix the way you read in the text to make sure that you get a vector with all words in chapter as individual entries also filter any non-letter characters and now identify the longest word.

```{r,accordion=TRUE}
shelley.vec2 <- scan(file="https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/book_chapter.txt", what='character', sep=' ', quote=NULL)
shelley.filt2 <- gsub(pattern='[^[:alnum:] ]', replacement="", x=shelley.vec2)
which(nchar(shelley.filt2) == max(nchar(shelley.filt2)))
shelley.filt2[301]
```

# `read.table()`

This is the by far most common way to get data into R. As the function creates a data frame at import it will only work for data set that fits those criteria, meaning that the data needs to have a set of columns of equal length that are separated with a common string eg. tab, comma, semicolon etc.

In this code block with first import the data from [normalized.txt](https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/normalized.txt) and accept the defaults for all other arguments in the function. With this settings R will read it as a tab delimited file and will use the first row of the data as colnames (header) and the first column as rownames.

```{r,accordion=TRUE}
expr.At <- read.table("https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/normalized.txt")
head(expr.At)
```

One does however not have to have all data as a file an the local disk, instead one can read data from online resources. The following command will read in a file from a web server.

```{r,accordion=TRUE}
url <- 'http://archive.ics.uci.edu/ml/machine-learning-databases/abalone/abalone.data'
abalone <- read.table(url, header=FALSE , sep=',')
head(abalone)
```

1. Read this [example data](https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/example.data) to R using the `read.table()` function. This files consist of gene expression values. Once you have the object in R validate that it looks okay and export it using the `write.table` function.

```{r,accordion=TRUE}
ed <- read.table("https://raw.githubusercontent.com/NBISweden/workshop-r/master/data/lab_loadingdata/example.data", sep=":")
head(ed)
str(ed)
```

Encode all NA values as "missing", at export.

```{r,eval=FALSE,accordion=TRUE}
write.table(x=ed, na="missing", file="example_mis.data")
```

2.  Read in the file you just created and double-check that you have the same data as earlier.

```{r,eval=FALSE,accordion=TRUE}
df.test <- read.table("example_mis.data", na.strings="missing")
```

3. Analysing genome annotation in R using read.table

For this exercise we will load a GTF file into R and calculate some basic summary statistics from the file. In the first part we will use basic manipulations of data frames to extract the information. In the second part you get a try out a library designed to work with annotation data, that stores the information in a more complex format, that allow for easy manipulation and calculation of summaries from genome annotation files.

For those not familiar with the gtf format it is a file format containing annotation information for a genome. It does not contain the actual DNA sequence of the organism, but instead refers to positions along the genome.

A valid GTF file should contain the following tab delimited fields (taken from the ensembl home page).

1.  **seqname** - name of the chromosome or scaffold; chromosome names can be given with or without the 'chr' prefix.
2.  **source** - name of the program that generated this feature, or the data source (database or project name)
3.  **feature** - feature type name, e.g. gene, transcript, exon, CDS, start_codon, end_codon 
4.  **start** - Start position of the feature, with sequence numbering starting at 1.
5.  **end** - End position of the feature, with sequence numbering starting at 1.
6.  **score** - A floating point value.
7.  **strand** - defined as + (forward) or - (reverse).
8.  **frame** - One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
9.  **attribute** - A semicolon-separated list of tag-value pairs, providing additional information about each feature.

|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|
1|transcribed_unprocessed_pseudogene|gene|11869|14409|.|+|.|gene_id; "ENSG00000223972";|
|1|processed_transcript|transcript|11869|14409|.|+|.|gene_id; "ENSG00000223972";|

The last column can contain a large number of attributes that are semicolon-separated.

As these files for many organisms are large we will in this exercise use the latest version of Drosophila melanogaster genome annotation available at `ftp://ftp.ensembl.org/pub/release-86/gtf/drosophila_melanogaster` that is small enough for analysis even on a laptop.  

Download the file named **Drosophila_melanogaster.BDGP6.86.gtf.gz** to your computer. Unzip this file and keep track of where your store the file.

With this done read this file into R using the function `read.table()` and add meaningful column names to the table.

```{r,include=FALSE,eval=TRUE}
if(!file.exists("Drosophila_melanogaster.BDGP6.86.gtf")) {
  if(!file.exists("Drosophila_melanogaster.BDGP6.86.gtf.gz")) {
    download.file("ftp://ftp.ensembl.org/pub/release-86/gtf/drosophila_melanogaster/Drosophila_melanogaster.BDGP6.86.gtf.gz","Drosophila_melanogaster.BDGP6.86.gtf.gz")
    system("gunzip Drosophila_melanogaster.BDGP6.86.gtf.gz")
  }
}
```

```{r,accordion=TRUE}
d.gtf <- read.table("Drosophila_melanogaster.BDGP6.86.gtf", header=FALSE, comment.char="#", sep="\t")
colnames(d.gtf) <- c("Chromosome","Source","Feature", "Start","End","Score","Strand","Frame","Attribute")
```

Prior to any analysis you should make sure that your attempt to read in the file has worked as expected. This can for example be done by having a look at the dimension of the stored object and making sure that it has the structure you expect.

```{r,accordion=TRUE}
dim(d.gtf)
str(d.gtf)
```

1.  How many chromosome names can be found in the annotation file?

```{r,accordion=TRUE}
levels(d.gtf$Chromosome)
```

2.  How many **exons** is there in total and per chromosome? (hint: first extract lines that have `feature == 'exon'`)   

```{r,accordion=TRUE}
d.gtf.exons <- d.gtf[(d.gtf$Feature == 'exon'),]
aggregate(d.gtf.exons$Feature, by=list(d.gtf.exons$Chromosome), summary)
```


```{r,accordion=TRUE}
by(data=d.gtf$Feature, d.gtf[,"Chromosome"], summary)
```

3.  Filter the data frame to only retain gene annotations

```{r,accordion=TRUE}
d.gtf.gene <- d.gtf[d.gtf$Feature == "gene",]
```

4.  What is the average gene length of in the Drosophila genome?

```{r,accordion=TRUE}
mean(abs(d.gtf.gene$Start - d.gtf.gene$End))
```

5.  What fraction of the genes are encoded on the plus strand of the genome.

```{r,accordion=TRUE}
sum(d.gtf.gene$Strand == "+") / length(d.gtf.gene$Strand)
```

6.  What is the median and mean length of the exons found on chromosome 3R in the data set?

```{r,accordion=TRUE}
d.gtf3R <- d.gtf[d.gtf$Chromosome == "3R",]
exon.position <- d.gtf3R[d.gtf3R$Feature == "exon",c("Start", "End")]   
median(abs(exon.position$Start - exon.position$End))
mean(abs(exon.position$Start - exon.position$End))
```

7.  Do the same calculations for the chromosomes 2L, 2R, 3L, 4, X and Y using a for loop.

```{r,accordion=TRUE}
chr <- c("2L","2R","3L","4","X","Y")
for (i in chr) {
  d.gtf.tmp <- d.gtf[d.gtf$Chromosome == i,]
  exon.position <- d.gtf.tmp[d.gtf.tmp$Feature == "exon", c("Start", "End")]   
  exon.med <- median(abs(exon.position$Start - exon.position$End))
  exon.mean <- mean(abs(exon.position$Start - exon.position$End))
  txt <- sprintf("The median and mean exon length for %s is %g and %g, respectively", i, exon.med, exon.mean)
  print(txt)
}
```

```{r,eval=TRUE,include=FALSE}
# remove drosophila gtf
if(file.exists("Drosophila_melanogaster.BDGP6.86.gtf")) file.remove("Drosophila_melanogaster.BDGP6.86.gtf")
if(file.exists("Drosophila_melanogaster.BDGP6.86.gtf.gz")) file.remove("Drosophila_melanogaster.BDGP6.86.gtf.gz")
```

<!--chapter:end:lab_loadingdata.Rmd-->

---
title: "Loops in R"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

# Introduction

In programming languages loop structures, either with or without conditions, are used to repeat commands over multiple entities. For
and while loops as well as if-else statements are also often used in R, but not as often as in many other programming languages. The reason for this is that many needs of the loops are addressed using vectorization or via apply functions.

This means that we can multiply all values in a vector in R by two by calling

```{r}
vec.a <- c(1, 2, 3, 4)
vec.a * 2
```

In many other and languages as well as in R, you can also create this with a loop instead

```{r}
for (i in vec.a) {
  vec.a[i] <- vec.a[i] * 2
}

vec.a
```

As you saw in the lecture, this is far less efficient and not by any means easier to type and we hence tend to avoid loops when possible.

After this exercise you should know:

- What are the most common loop structures in R
- Some common alternatives to using loops in R
- How one can convert a short script to a function.
- Use that new function in R.

# Exercises

1. Create a 100000 by 10 matrix with the numbers 1:1000000. Make a for-loop that calculates the sum for each row of the matrix. Verify that your results are consistent with what you obtain with the `apply()` function to calculate row sums as well as with the built-in `rowSums()` function. These functions were discussed in the lecture **Elements of the programming language - part 2**.

```{r,accordion=TRUE,results='markup'}
X <- matrix(1:1000000, nrow = 100000, ncol = 10)
for.sum <- vector()
# Note that this loop is much faster if you outside the loop create an empty vector of the right size.
# rwmeans <- vector('integer', 100000)
for (i in 1:nrow(X)) {
    for.sum[i] <- sum(X[i,])
}
head(for.sum)

app.sum <- apply(X, MARGIN = 1, sum)
head(app.sum)

rowSums.sum <- rowSums(X)
head(rowSums.sum)

identical(for.sum, app.sum)
identical(for.sum, rowSums.sum)
identical(for.sum, as.integer(rowSums.sum))
```

2. Another common loop structure that is used is the while loop, which functions much like a for loop, but will only run as long as a test condition is TRUE. Modify your for loop from exercise 1 and make it into a while loop.

```{r,accordion=TRUE}
x <- 1
while.sum <- vector("integer", 100000)
while (x < 100000) {
  while.sum[x] <- sum(X[x,])
  x <- x + 1
}
head(while.sum)
```

3. Create a data frame with two numeric and one character vector. Write a loop that loops over the columns and reports the sum of the column values if it is numeric and the total number of characters if it is a character vector.  
**Tips** to count number of characters, you can use `nchar` function.  

```{r,accordion=TRUE}
vector1 <- 1:10
vector2 <- c("Odd", "Loop", letters[1:8])
vector3 <- rnorm(10, sd = 10)
dfr1 <- data.frame(vector1, vector2, vector3, stringsAsFactors = FALSE)
sum.vec <- vector()
for(i in 1:ncol(dfr1)) {
  if (is.numeric(dfr1[,i])) {
      sum.vec[i] <- sum(dfr1[,i])
  } else {
      sum.vec[i] <- sum(nchar(dfr1[,i]))
  }
}
sum.vec
```

4. In question 3 you generated a loop to go over a data frame. Try to convert this code to a function in R. The function should take a single data frame name as argument.

```{r,accordion=TRUE}
dfr.info <- function(dfr) {
  sum.vec <- vector()
  for (i in 1:ncol(dfr)) {
  	if (is.numeric(dfr[,i])) {
  		sum.vec[i] <- mean(dfr[,i])
  	} else {
  		sum.vec[i] <- sum(nchar(dfr[,i]))
  	}
  }
  sum.vec
}
```

5.  Read up on the if-else function in R. If possible use the if-else function to answer question 3.

6.  In all loops that we tried out we have created the variable where the output is saved outside the loop. Why is this?

<!--
7. <i class="fas fa-exclamation-circle"></i> **Advanced:** At the lecture an approach to calculate factorials were implemented using recursion (function calling itself). Here we instead will have a go at generating Fibonacci numbers. A fibonacci number is part of a series of number with the following properties:

The first two numbers in the Fibonacci sequence are either 1 and 1, or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number is the sum of the previous two. Hence:

`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

or

`1, 1, 2, 3, 5, 8, 13, 21, ...`

Try to generate such a series using a recursive approach.
-->

<!--chapter:end:lab_loops.Rmd-->

---
title: "Tidy Work in Tidyverse"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

```{r,echo=FALSE,message=FALSE,warning=FALSE,results='hide'}
library(dplyr)
library(nycflights13)
```

# Introduction

Welcome to the hands-on workshop "Tidy Work in Tidyverse". Most of the things necessary to complete the tutorials and challenges were covered in the lecture. However, sometimes the tasks require that you check the docs or search online. Not all our solutions are optimal. Let us know if you can do better or solve things in a different way. If stuck, look at hints, next google and if still stuck, turn to TA. It is a lot of material, do not fee bad if you do not solve all tasks. Good luck!

# Pipes

- Rewrite the following code chunk as one pipe (`magrittr`):

```{r,eval=FALSE}
my_cars <- mtcars[, c(1:4, 7)]
my_cars <- my_cars[my_cars$disp > mean(my_cars$disp), ]
print(my_cars)
my_cars <- colMeans(my_cars)
```

```{r, accordion=TRUE, echo=TRUE, eval=FALSE}
my_cars <- mtcars %>%
  select(c(1:4, 7)) %>%
  filter(disp > mean(disp)) %T>%
  print() %>%
  colMeans()
```

- Rewrite the correlations below using pipes.

```{r,eval=FALSE}
cor(mtcars)
```

```{r, accordion=TRUE, echo=TRUE, eval=FALSE}
mtcars %>% cor()
```

```{r,eval=FALSE}
cor(mtcars$gear, mtcars$mpg)
```

```{r, accordion=TRUE, echo=TRUE, eval=FALSE}
mtcars %$% cor(gear, mpg)
```

# Tibbles

- Convert the `mtcars` dataset to a tibble `vehicles`.

```{r,accordion=TRUE}
vehicles <- mtcars %>% as_tibble()
```

- Select the number of cylinders (`cyl`) variable using:
    - the `[[index]]` accessor,
    - the `[[string]]` accessor,
    - the `$` accessor.
    
```{r,accordion=TRUE}
vehicles[['cyl']]
vehicles[[2]]
vehicles$cyl
```

- Do the same selection as above, but using pipe and placeholders (use all three ways of accessing a variable).

```{r,accordion=TRUE}
vehicles %T>%
  {print(.[['cyl']])} %T>%
  {print(.[[2]])} %>%
  .$cyl
```

- Print the tibble.

```{r,accordion=TRUE}
vehicles
```

- Print the 30 first rows of the tibble.

```{r,accordion=TRUE}
vehicles %>% head(n = 30)
```

- Change the default behaviour of printing a tibble so that at least 15 and at most 30 rows are printed.

```{r,accordion=TRUE}
options(tibble.print_min = 15, tibble.print_max = 30)
```

- Convert `vehicles` back to a `data.frame` called `automobiles`.

```{r,accordion=TRUE}
automobiles <- as.data.frame(vehicles)
```

Do you think tibbles are lazy? Try to create a tibble that tests whether *lazy evaluation* applies to tibbles too.

```{r eval=FALSE}
tibble(x = sample(1:10, size = 10, replace = T), y = log10(x))
```

# NYC flights Challenge

The `nycflights13` package contains information about all flights that departed from NYC (i.e., EWR, JFK and LGA) in 2013: 336,776 flights with 16 variables. To help understand what causes delays, it also includes a number of other useful datasets: weather, planes, airports, airlines. We will use it to train working with tibbles and `dplyr`.

## Selecting columns

- Load the `nycflights13` package (install if necessary)

```{r,accordion=TRUE,eval=FALSE}
install.packages('nycflights13')
library(nycflights13)
```

- Read about the data in the package docs

```{r,accordion=TRUE}
?nycflights13
```

- Inspect the `flights` tibble.

```{r,accordion=TRUE}
flights
```

- Select all columns but `carrier` and `arr_time`

```{r,accordion=TRUE}
flights %>% select(-carrier, -arr_time)
```

- Select `carrier`, `tailnum` and `origin`

```{r,accordion=TRUE}
flights %>% select(carrier, tailnum, origin)
```

- Hide columns from `day` through `carrier`

```{r,accordion=TRUE}
flights %>% select(-(day:carrier))
```

- Select all columns that have to do with `arr`ival (hint: `?tidyselect`)

```{r,accordion=TRUE}
flights %>% select(contains('arr_'))
```

- Select columns based on a vector `v <- c("arr_time", "sched_arr_time", "arr_delay")`

```{r,accordion=TRUE}
v <- c("arr_time", "sched_arr_time", "arr_delay")
flights %>% select(v) # or
flights %>% select(one_of(v))
```

- Rename column `dest` to `destination` using `select()` and `rename()`. What is the difference between the two approaches?

```{r,accordion=TRUE}
flights %>% select(destination = dest) %>% head()
flights %>% rename(destination = dest) %>% head()
# select keeps only the renamed column while rename returns the whole dataset
# with the column renamed
```

## Filtering rows

- Filter only the flights that arrived ahead of schedule

```{r,accordion=TRUE}
flights %>% filter(arr_delay < 0)
```

- Filter the flights that had departure delay between 10 and 33

```{r,accordion=TRUE}
flights %>% filter(dep_delay >= 10, dep_delay <= 33) # or
flights %>% filter(between(dep_delay, 10, 33))
```

- Fish out all flights with unknown arrival time

```{r,accordion=TRUE}
flights %>% filter(is.na(arr_time))
```

- Retrieve rows 1234:1258 (hint: `?slice`)

```{r,accordion=TRUE}
flights %>% slice(1234:1258)
```

- Sample (`?sample_n()`) 3 random flights per day in March

```{r,accordion=TRUE}
flights %>% filter(month == 3) %>%
  group_by(day) %>%
  sample_n(3)
```

- Show 5 most departure-delayed flights in January per carrier

```{r,accordion=TRUE}
flights %>%
  filter(month == 1) %>%
  group_by(carrier) %>%
  top_n(5, dep_delay)
```

- How many unique routes exists?

```{r,accordion=TRUE}
flights %>%
  mutate(route=paste(origin,"-",dest)) %>%
  distinct(route,.keep_all=T) %>%
  nrow()
```

- Which is the most frequent route?

```{r,accordion=TRUE}
# JFK - LAX
flights %>%
  mutate(route=paste(origin,"-",dest)) %>% 
  group_by(route) %>%
  count() %>%
  arrange(-n)
```

## Trans(mutations)

- `air_time` is the amount of time in minutes spent in the air. Add a new column `air_spd` that will contain aircraft's airspeed in mph

```{r,accordion=TRUE}
flights %>% mutate(air_spd = distance/(air_time / 60))
```

- As above, but keep only the new `air_spd` variable

```{r,accordion=TRUE}
flights %>% transmute(air_spd = distance/(air_time / 60))
```

## Groups and counts

- Use `group_by()`, `summarise()` and `n()` to see how many planes were delayed (departure) every month

```{r,accordion=TRUE}
flights %>%
  filter(dep_delay > 0) %>%
  group_by(month) %>%
  summarise(num_dep_delayed = n())
```

- What was the mean `dep_delay` per month?

```{r,accordion=TRUE}
flights %>%
  group_by(month) %>%
  summarise(mean_dep_delay = mean(dep_delay, na.rm = T))
```

- Count the number of incoming delayed flights from each unique origin and sort origins by this count (descending)

```{r,accordion=TRUE}
flights %>%
  filter(arr_delay > 0) %>%
  group_by(origin) %>%
  summarise(cnt = n()) %>%
  arrange(desc(cnt))
```

- Use `summarise()` to sum total `dep_delay` per month in hours

```{r,accordion=TRUE}
 flights %>%
   group_by(month) %>%
   summarize(tot_dep_delay = sum(dep_delay/60, na.rm = T))
```

- Run `group_size()` on `carrier` what does it return?

```{r,accordion=TRUE}
flights %>%
    group_by(carrier) %>%
    group_size()
```

- Use `n_groups()` to check the number of unique origin-carrier pairs,

```{r,accordion=TRUE}
flights %>%
    group_by(carrier) %>%
    n_groups()
```

**Note on `ungroup`** Depending on the version of `dplyr` you may or may need to use the `ungroup()` if you want to group your data on some other variables. In the newer versions, `summarise` and `mutate` drop one aggregation level.

<!--chapter:end:lab_tidyverse.Rmd-->

---
title: "Working with Vectors"
subtitle: "R Programming Foundation for Life Scientists"
output:
  bookdown::html_document2:
    highlight: textmate
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      print: false
    toc_depth: 4
    number_sections: true
    df_print: default
    code_folding: none
    self_contained: false
    keep_md: false
    encoding: 'UTF-8'
    css: "assets/lab.css"
    include:
      after_body: assets/footer-lab.html
---

```{r,child="assets/header-lab.Rmd"}
```

# Introduction

There are several different data structures that are commonly used in R. The different data structures can be seen as different ways to organise data. In this exercise we will focus on vectors, which are the base data structure in R, and will also get an overview of the key data types (modes) that are found in R. At the end of this exercise you should know:

-   What are the data types commonly used in R.
-   What is a vector.
-   How to create vectors in an interactive R session.
-   How one can use R functions to determine the structure and mode of an vector.
-   What basic operators you can find in R
-   How to subset vector using both indexes and operators.
-   Try some of the built-in functions in R.

## Data types

From the lecture you might remember that all elements in any data stuctures found in R will be of a certain type (or have a certain mode). The four most commonly used data types in R are: logical, integer, double (often called numeric), and character. The names hints at what they are.

-   Logical = TRUE or FALSE (or NA)
-   Integer = Numbers that can be represented without fractional component
-   Numeric = Any number that is not a complex number
-   Character = Text

In many cases the mode of an entry is determined by the content so if you save the value 5.1 as a variable in R, the variable will by R automatically be recognised as numeric. If you instead have a text string like "hello world" it will have the mode character. Below you will also see examples of how you can specify the mode and not rely on R inferring the right mode based on content.

## Vectors in R

Depending on the type of data one needs to store in R different data structures can be used. The four most commonly used data types in R is
vectors, lists, matrixes and data frames. We will in this exercise work only with vectors.

The most basic data structure in R are vectors. Vectors are 1-dimensional data structures that contain only one type of data (eg. all entries must have the same mode). To create a vector in R one can use the function `c()` (concatenate or combine) as seen below. This example will create a vector named example.vector with 3 entries in it.

```{r}
example.vector <- c(10, 20, 30)
```

<i class="fas fa-lightbulb"></i> If you need more information about the function `c()` you can always use the built-in manual in R. Typing `?c()` will bring up the documentation for the function `c()`.

Once you have created this vector in R, you can access it by simply typing its name in an interactive session.

```{r}
example.vector
```

The output generate on screen shows the entries in your vector and the 1 in squared brackets indicates what position in the vector the entry to the right of it has. In this case 10 is the first entry of the vector.

If we for some reason only wanted to extract the value 10 from this vector we can use the fact that we know it is the first position to do so.

```{r}
example.vector[1]
```

Since a vector can only contain one data type, all members need to be of the same type. If you try to combine data of different types into the same vector, R will not warn you, but instead coerce it to the most flexible type (From least to most flexible: Logical, integer, double, character). Hence, adding a number to a logical vector will turn the whole vector to a numeric vector.

To check what data type an object is, run the R built-in function `class()`, with the object as the only parameter.

```{r}
class(example.vector)
```

If you for any reason want to have more information about any object you have stored in your R session the command `str()` is very helpful.

```{r}
str(example.vector)
```

## Basic R operators

As in other programming languages there are a set of basic operators in R.

| Operation | Description | Example | Example Result |
|---|---|---|---|
|`x + y`|Addition|`1 + 3`|`4`|
|`x - y`|Subtraction|`1 - 3`|`-2`|
|`x * y`|Multiplication|`2 * 3`|`6`|
|`x / y`|Division|`1 / 2`|`0.5`|
|`x ^ y`|Exponent|`2 ^ 2`|`4`|
|`x %% y`|Modular arethmetic|`1 %% 2`|`1`|
|`x %/% y`|Integer division|`1 %/% 2`|`0`|
|`x == y`|Test for equality|`1 == 1`|`TRUE`|
|`x <= y`|Test less or equal|`1 <= 1`|`TRUE`|
|`x >= y`|Test for greater or equal|`1 >= 2`|`FALSE`|
|`x && y`|Non-vectorized boolean AND|`c(T,F) && c(T,T)`|`TRUE`|
|`x & y`|Vectorized boolean AND|`c(T,F) & c(T,T)`|`TRUE FALSE`|
|`x || y`| Non-vectorized boolean OR|`c(T,F) || c(T,T)`|`TRUE`|
|`x | y`|Vectorized boolean OR|`c(T,F) || c(T,T)`|`TRUE TRUE`|
|`!x`|Boolean not|`1 != 2`|`TRUE`|

Besides these, there of course numerous more or less simple functions available in any R session. For example, if we want to add all values in our example.vector that we discussed earlier, we can do that using addition:

```{r}
example.vector[1] + example.vector[2] + example.vector[3]
```

But we can also use the function `sum()` that adds all numeric values present as arguments.

```{r}
sum(example.vector)
```

To learn more about a function use the built in R manual as described earlier. If you do not know the name of a function that you believe should be found in R, use the function `help.search()` or use google to try and identify the name of the command.

# Exercise

In all exercises on this course it is important that you prior to running the commands in R, try to figure out what you expect the result to be. You should then verify that this will indeed be the result by running the command in an R session. In case there is a discrepency between your expectations and the actual output make sure you understand why before you move forward. If you can not figure out howto, or which command to run you can click the key to reveal example code including expected output. Also note that in many cases there multiple solutions that solve the problem equally well.

## Create and modify vectors

Open R-studio and create two numeric vectors named x and y that are of equal length. Use these vectors to answer the questions below.

```{r}
x <- c(2, 4 ,7)
y <- c(1, 5, 11)
```

1.  How many numbers are there in the vector x?

```{r,accordion=TRUE}
length(x)
```

2.  How many numbers will x + y generate?

```{r,accordion=TRUE}
length(x + y)
```

3.  What is the sum of all values in x?

```{r,accordion=TRUE}
sum(x)
```

4.  What is the sum of y times y?

```{r,accordion=TRUE}
sum(y*y)
```

5.  What do you get if you add x and y?

```{r,accordion=TRUE}
x + y
```

6.  Assign x times 2 to a new vector named z

```{r,accordion=TRUE}
z <- x * 2
```

7.  How many numbers will z have, why?

```{r,accordion=TRUE}
length(z)
```

8.  Assign the mean of z to a new vector named z.mean and determine the length of z.mean

```{r,accordion=TRUE}
z.mean <- mean(z)  
length(z.mean) 
```

9.  Create a numeric vector with all integers from 5 to 107

```{r,accordion=TRUE}
vec.tmp <- 5:107  
vec.tmp
```

10. Create a numeric vector with the same length as the previos one, but only containg the number 3

```{r,accordion=TRUE}
vec.tmp2 <- rep(3, length(vec.tmp))  
vec.tmp2
```

11. Create a vector that contain all numbers from 1 to 17, where each number occurs the the same number of times as the number itself eg. 1, 2, 2, 3, 3, 3...

```{r,accordion=TRUE}
rep(1:17, 1:17) 
```

12. What will be the result of the following calculations?
	- `c(1, 3, 5) + c(2, 4, 6)`
	- `c(1, 3, 5) + c(2, 4, 6, 8)`
	- `c(1, 3) - c(2, 4, 6 ,8)`

13. Create two numeric vectors of length 4 and test run all the basic operators (as seen in the table earlier) with these two as arguments. Make sure you understand the output generated by R.

## Modify and subset vectors

Create a new character vector that contains the following words and save it using a suitable name:
`apple, banana, orange, kiwi, potato`.

```{r,accordion=TRUE}
veggies <- c("apple", "banana", "orange", "kiwi", "potato")
```

Do the following on your newly created vector.

1. Select orange from the vector.

```{r,accordion=TRUE}
veggies[3]
```

2. Select all fruits from the vector.

```{r,accordion=TRUE}
veggies[-5]  
veggies[1:4]  
```

3. Do the same selection as in question 2 without using index positions.

```{r,accordion=TRUE}
veggies[veggies=="apple" | veggies == "banana" | veggies == "orange" | veggies == "kiwi"]  
veggies[veggies!="potato"]  
```

4. Convert the character string to a numeric vector.

```{r,accordion=TRUE}
as.numeric(veggies)  
```

5. Create a vector of logic values that can be used to extract every second value from your character vector.

```{r,accordion=TRUE}
selection <- c(FALSE, TRUE, FALSE, TRUE, FALSE)  
veggies[selection]  
```

Alternative solution, why do this work?

```{r,accordion=TRUE}
selection2 <- c(FALSE, TRUE)  
veggies[selection2]  
```

6.  Add the names a, b, o, k and p to the vector.

```{r,accordion=TRUE}
names(veggies) <- c("a", "b", "o", "k", "p")  
```

7.  Create a vector containing all the letters in the alphabet (NB! this can be done without having to type all letters). Google is your friend.

```{r,accordion=TRUE}
letters  
```

8.  Sample 30 values randomly with replacement from your letter vector and convert the character vector to factors. Which of the levels have most entries in the vector?

```{r,accordion=TRUE}
letter.sample <- sample(letters, size = 30, replace = TRUE)  
letter.sample <- factor(letter.sample)  
summary(letter.sample)  
```

9.  Extract the letter 14 to 19 from the alphabet vector created previously.

```{r,accordion=TRUE}
letters[14:19]  
```

10. Extract all but the last letter.

```{r,accordion=TRUE}
letters[1:length(letters)-1]  

letters[-length(letters)]  
```

11. Which is the index position of the letter u in the vector?

```{r,accordion=TRUE}
which(letters=="u")  
```

12. Create a new vector of length one that holds all the alphabet a single entry.

```{r,accordion=TRUE}
paste(letters, sep = "", collapse = "")  
```

13. Create a numeric vector by sampling 100 numbers from a normal distribution with mean 2 and standard deviation 4. Hint! Check the function `rnorm()`.

```{r,accordion=TRUE}
norm.rand <- rnorm(100, mean = 2, sd = 4)  
```

14. How many of the generated values are negative?

```{r,accordion=TRUE}
length(norm.rand[norm.rand<0])  
```

15. Calculate the standard deviation, mean, median of your random numbers.

```{r,accordion=TRUE}
sd(norm.rand)  
mean(norm.rand)  
median(norm.rand)  
```

16. Replace the 11th value in your random number vector with NA and calculate the same summary statistics again.

```{r,accordion=TRUE}
norm.rand[11] <- NA  
sd(norm.rand, na.rm = TRUE)  
mean(norm.rand, na.rm = TRUE)  
median(norm.rand, na.rm = TRUE)  
```

17. Replace the last position in the vector with the letter L and calculate the same summary statistics.
   
```{r,accordion=TRUE}
norm.rand[100] <- "L"  
sd(norm.rand, na.rm = TRUE)  
mean(norm.rand, na.rm = TRUE)  
median(norm.rand, na.rm = TRUE)  
```

18. In many cases one has data from multiple replicates and different treatments in such cases it can be useful to have names of the type: Geno\_a\_1, Geno\_a\_2, Geno\_a\_3, Geno\_b\_1, Geno\_b\_2&#x2026;, Geno\_s\_3. Try to create this such a vector without manually typing it all in.

```{r,accordion=TRUE}
geno <- rep("Geno", 57)  
needed.letters <- rep(letters[1:19], 3)  
needed.numbers <- rep(1:3, 19)  
temp <- paste(geno, needed.letters, needed.numbers, sep = "_")  
sort(temp)  

# One line solution that avoids need of knowing length(geno) and sorting
# Find s position in alphabet
which(letters == "s")
paste("Geno",rep(letters[1:19],rep(3,19)),1:3,sep="_")

```

<!--chapter:end:lab_vectors.Rmd-->

---
title: "Base R graphics"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak"
keywords: "bioinformatics, course, scilifelab, nbis, R"
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, width=60, fig.align = 'center')
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
#library(mkteachr)
```

---
name: ex1_graphics

# Example graphics

.pull-left-50[
.size-80[![](data/slide_base_graphics/world.png)]

Stability of the climate (courtesy of Dr. Mats Pettersson).
]

--

.pull-right-50[
.size-80[![](data/slide_base_graphics/Face_of_Asia.png)]
]

---
name: ex2_graphics

# Example graphics

.pull-left-50[
![](data/slide_base_graphics/airports_pl.png)

]

--

.pull-right-50[
![](data/slide_base_graphics/gapminder.png)
]

---
name: grapgical_devices
class: spaced

# Graphical devices

The concept of a **graphical device** is crucial for understanding R graphics.  

--
A device can be a screen (default) or a file. Some R packages introduce their own devices, e.g. Cairo device.

--
Creating a plot entails:
* opening a graphical device (not necessary for plotting on screen),

--
* plotting to the graphical device,

--
* closing the graphical device (very important!)

--

# The most commonly used graphical devices are:

* screen,
* bitmap/raster devices: `png()`, `bmp()`, `tiff()`, `jpeg()`
* vector devices: `svg()`, `pdf()`,
* `Cairo` versions of the above devices &ndash; for Windows users they offer higher quality graphics,

--
For more information visit [this link](http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/Devices.html).

---
name: working_with_graphical_devs
class: spaced

# Working with graphical devices

```{r graphdevex, eval=FALSE, tidy=FALSE}
png(filename = 'myplot.png', width = 320, height = 320, antialias = T)
plot(x=c(1,2,7), y=c(2,3,5))
dev.off()
```

--

What we did was, in sequence:

* open a graphical device, here `png()` with some parameters,
* do the actual plotting to the device using `plot()` and
* close the graphical device using `dev.off()`.

--

> It is of paramount importance to remember to close graphical devices. Otherwise, our plots may end up in some random weird files or on screens.

---
name: std_viewport

# Standard graphical device viewport

.size-60[![](data/slide_base_graphics/rmargins_sf.png)]
.small[source: rgraphics.limnology.wisc.edu]

---
name: plot_basics

# `base::plot()` basics

`base::plot()` is a basic command that lets you visualize your data and results. It is very powerful yet takes some effort to fully master it. Let's begin with plotting three points:

* A(1,2);
* B(2,3);
* C(7,5);

.size-40[
```{r plot1, eval=TRUE}
plot(x=c(1,2,7), y=c(2,3,5))
```
]

---
name: plot_data_frame

# Anatomy of a plot &mdash; episode 1

For convenience, we will create a data frame with our points:

.pull-left-50[
```{r plot1a, eval=TRUE, tidy=TRUE}
df <- data.frame(x=c(1,2,7), y=c(2,3,5),
row.names=c("A","B","C"))
df
```
]

.pull-right-50[
```{r, echo=TRUE}
plot(df)
```
]

---
name: plot_anatomy_2

# Anatomy of a plot &mdash; episode 2

.pull-left-50[
There is many parameters one can set in `plot()`. Let's have a closer look at some of them:
* pch &ndash; type of the plotting symbol
* col &ndash; color of the points
* cex &ndash; scale for points
* main &ndash; main title of the plot
* sub &ndash; subtitle of the plot
* xlab &ndash; X-axis label
* ylab &ndash; Y-axis label
* las &ndash; axis labels orientation
* cex.axis &ndash; axis lables scale
]

.pull-right-50[
Let's make our plot a bit fancier...
```{r plot2, eval=TRUE, tidy=TRUE}
# recycling rule in action!
plot(df, pch=c(15,17,19),
col=c("tomato", "slateblue"),
main="Three points", sub="Stage 1")
```
]

---
name: gr_param

# Graphical parameters

Graphical parameters can be set in two different ways:

* as plotting function arguments, e.g. `plot(dat, cex = 0.5)`
* using `par()` to set parameters globally

```{r gr.params, eval=TRUE, tidy=FALSE, eval=FALSE}
# read current graphical parameters
par()
# first, save the current parameters so that you
# can set them back if needed
old_par <- par() # should work in theory, practise varies :-(
# now, modify what you want
par(cex.axis = 0.8, bg='grey')
# do your plotting
plot(................)
# restore the old parameters if you want
par(old_par)
```

---
name: pch_plot

# The `pch` parameter

.size-80[
```{r par.pch, echo=FALSE, tidy=FALSE}
# create a grid of coordinates
coords <- expand.grid(1:6,1:6)
# make a vector of numerical pch symbols
pch.num <- c(0:25)
# and a vector of character pch symbols
pch.symb <- c('*', '.', 'o', 'O', '0', '-', '+', '|', '%', '#')
# plot numerical pch
plot(coords[1:26,1], coords[1:26,2], pch=pch.num,
bty='n', xaxt='n', yaxt='n', bg='red',
xlab='', ylab='')
# and character pch's
points(coords[27:36,1], coords[27:36,2], pch=pch.symb, cex=3)
# label them
text(coords[,1], coords[,2], c(1:26, pch.symb), pos = 1,
col='slateblue', cex=.8)
```
]

---
name: pch_cheatsheet_code

# How to make the `pch` cheatsheet

```{r par.pch2, echo=TRUE, tidy=FALSE, eval=FALSE}
# create a grid of coordinates
coords <- expand.grid(1:6,1:6)
# make a vector of numerical pch symbols
pch.num <- c(0:25)
# and a vector of character pch symbols
pch.symb <- c('*', '.', 'o', 'O', '0', '-', '+', '|', '%', '#')
# plot numerical pch
plot(coords[1:26,1], coords[1:26,2], pch=pch.num,
bty='n', xaxt='n', yaxt='n', bg='red',
xlab='', ylab='')
# and character pch's
points(coords[27:36,1], coords[27:36,2], pch=pch.symb)
# label them
text(coords[,1], coords[,2], c(1:26, pch.symb), pos = 1,
col='slateblue', cex=.8)
```
> Now, make your own cheatsheet for the **lty** parameter!

---
name: layers_1

# Layers

Elements are added to a plot in the same order you plot them.
It is like layers in a graphical program. Think about it! For instance the auxiliary grid lines should be plotted before the actual data points.

.pull-left-50[
```{r gr.layers, eval=TRUE, tidy=TRUE, eval=FALSE}
# make an empty plot
plot(1:5, type='n', las=1, bty='n')
grid(col='grey', lty=3)
points(1:5, pch=19, cex=3)
abline(h = 3.0, col='red')
```
]
.pull-right-50[
```{r gr.layers.ex, eval=TRUE, tidy=TRUE, eval=TRUE, echo=FALSE}
plot(1:5, type='n', las=1, bty='n')
grid(col='grey', lty=3)
points(1:5, pch=19, cex=3)
abline(h = 3.0, col='red')
```
]
The line overlaps one data point. It is better to plot it before plotting `points()`

---
name: general_thoughts
class: spaced

# Some thoughts about plotting

There is a few points you should have in mind when working with plots:

--
* raster or vector graphics,

--
* colors, e.g. color-blind people, warm vs. cool colors and optical illusions,

--
* avoid complications, e.g. 3D plots, pie charts etc.,

--
* use black and shades of grey for things you do not need to emphasize, i.e. basically everything except your main result,

--
* avoid 3 axes on one figure.

---
name: many_plots_on_one_fig

# Many plots on one figure

.pull-left-40[
```{r mfrow,  tidy=FALSE, echo=TRUE, eval=FALSE}
par(mfrow=c(2,3))
plot(1:5)
plot(1:5, pch=19, col='red')
plot(1:5, pch=15, col='blue')
hist(rnorm(100, mean = 0, sd=1))
hist(rnorm(100, mean = 7, sd=3))
hist(rnorm(100, mean = 1, sd=0.5))
par(mfrow=c(1,1))
```
Alternative: use `par(mfcol=c(3,2))`.
]

--

.pull-right-60[
```{r mfrow.ex,  tidy=FALSE, echo=FALSE, eval=TRUE}
par(mfrow=c(2,3))
plot(1:5)
plot(1:5, pch=19, col='red')
plot(1:5, pch=15, col='blue')
hist(rnorm(100, mean = 0, sd=1))
hist(rnorm(100, mean = 7, sd=3))
hist(rnorm(100, mean = 1, sd=0.5))
par(mfrow=c(1,1))
```
]

---
name: layout

# Using `graphics::layout()`

.pull-left-50[
```{r layout, echo=TRUE, eval=TRUE, fig.show='hide'}
M <- matrix(c(1,2,2,2,3,2,2,2), nrow = 2, ncol = 4, byrow = T)
layout(mat = M)
plot(1:5, pch=15, col='blue')
hist(rnorm(100, mean = 0, sd=1))
plot(1:5, pch=15, col='red')
M
```
]

--

.pull-right-50[
```{r layout_ex, echo=TRUE, eval=TRUE}
M <- matrix(c(1,2,2,2,3,2,2,2), nrow = 2, ncol = 4, byrow = T)
layout(mat = M)
plot(1:5, pch=15, col='blue')
hist(rnorm(100, mean = 0, sd=1))
plot(1:5, pch=15, col='red')
```
]

---
name: colors

# Defining colors

```{r color, echo=TRUE, tidy=TRUE, eval=FALSE}
mycol <- c(rgb(0,0,1), 'olivedrab', '#FF0000')
plot(1:3,c(1,1,1), col=mycol, pch=19, cex=3)
points(2,1, col=rgb(0,0,1,0.5), pch=15, cex=5)
```

--
```{r color_ex, echo=FALSE, tidy=TRUE, eval=TRUE, fig.align='center', fig.height=5, fig.width=5}
mycol <- c(rgb(0,0,1), 'olivedrab', '#FF0000')
plot(1:3,c(1,1,1), col=mycol, pch=19, cex=3, las=1)
points(2,1, col=rgb(0,0,1,0.5), pch=15, cex=5)
```

---
name: palettes

# Color palettes

There some built-in palettes: default, hsv, gray, rainbow, terrain.colors, topo.colors, cm.colors, heat.colors
```{r color.pal, echo=TRUE, tidy=TRUE, size='tiny', fig.align='center', fig.width=5, fig.height=4}
mypal <- heat.colors(10)
mypal
pie(x = rep(1, times = 10), col = mypal)
```

---
name: custom_palettes

# Custom color palettes

.pull-left-50[
You can easily create custom palettes:
```{r color.pal.custom, echo=TRUE, tidy=TRUE, eval=TRUE}
mypal <- colorRampPalette(c("red", "green", "blue"))
pie(x = rep(1, times = 12), col = mypal(12))
class(mypal)
```
]

--

.pull-right-50[
> **Note:**`grDevices::colorRampPalette()` returns a function for generating colors based on the defined custom palette!

> There is an excellent package `RColorBrewer` that offers a number of pre-made palettes, e.g. color-blind safe palette.

> Package `wesanderson` offers palettes based on Wes Anderson's movies :-)
]

---
name: boxplot_theory

# Box-and-whiskers plot &mdash; theory

There are also more specialized R functions used for creating specific types of plots. One commonly used is `graphics::boxplot()`
.size-40[.center[![](data/slide_base_graphics/wiki_boxplot.png)]]

> **Rule of thumb.** If median of one boxplot is outside the box of another, the median difference is likely to be significant $\alpha = 5\%$.

---
name: boxplot

# Box-and-whiskers plot

.pull-left-50[
```{r boxplot, tidy=FALSE}
boxplot(decrease ~ treatment,
data = OrchardSprays,
log = "y", col = "bisque",
varwidth=TRUE)
```
]

--

.pull-right-50[
The `add=TRUE` parameter in plots allows you to compose plots using previously plotted stuff!

```{r boxplot2, tidy=FALSE, size="tiny", fig.height=4, fig.width=4}
attach(InsectSprays)
boxplot(count~spray, data=InsectSprays[spray %in% c("C","F"),], col="lightgray")
boxplot(count~spray, data=InsectSprays[spray %in% c("A","B"),], col="tomato", add=TRUE)
boxplot(count~spray, data=InsectSprays[spray %in% c("D","E"),], col="slateblue", add=TRUE)
detach(InsectSprays)
```
]

---
name: vioplot

# Violin plots

Package `vioplot` empowers your graphics repertoire with a variation of box-and-whiskers plot called *violin plot*.  

```{r vioplot, tidy=FALSE, message=FALSE, warning=FALSE, fig.height=4, fig.width=4}
attach(InsectSprays)
vioplot::vioplot(count[spray=="A"],
count[spray=="F"],
col="bisque",
names=c("A","F"))
detach(InsectSprays)
```
> A violin plot is very similar to a boxplot, but it also visualizes distribution of your datapoints.

---
name: vcd

# Plotting categorical data

```{r vcd.titanic,  tidy=FALSE, fig.height=4, fig.width=6, size='tiny', echo=TRUE}
data(Titanic) # Load the data
vcd::mosaic(Titanic,
            labeling = vcd::labeling_border(rot_labels = c(0,0,0,0)))
```
> Package `vcd` provides a lot of ways of visualizing categorical data.

---
name: heatmaps

# Plotting simple heatmaps

```{r heatmap,  tidy=FALSE, echo=TRUE, fig.width=5, fig.height=5}
heatmap(matrix(rnorm(100, mean = 0, sd = 1), nrow = 10),
col=terrain.colors(10))
```

---
name: graph_gallery

# Graph gallery

For more awesome examples visit: [http://www.r-graph-gallery.com](http://www.r-graph-gallery.com)

![](data/slide_base_graphics/graph_gallery.png)

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# Thank you! Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_base_graphics.Rmd-->

---
title: "Visualisation with `ggplot2`"
subtitle: "R Foundations for Life Scientists"
author: "Roy Francis"
keywords: r, rmarkdown, ggplot, graphics
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---
exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ----------------- Only edit title & author above this ----------------- -->

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load packages
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)

#colors
rv_col_dark <- "#125687"
rv_col_light <- "#e7eef3"

```

# Contents

* [Why `ggplot2`?](#intro)
* [Grammar of Graphics](#gog)
* [Data](#data-iris)
* [Geoms](#geom)
* [Aesthetics](#aes)
* [Scales](#scales-discrete-colour)
* [Facets](#facet-wrap)
* [Coordinates](#coordinate)
* [Theme](#theme)
* [Position](#position)
* [Saving Plots](#save)
* [Combining Plots](#comb)
* [Interactive Plots](#interactive)
* [Extensions](#extension)

---
name: intro
class: spaced

# Why `ggplot2`?

* Consistent code
* Flexible
* Automatic legends, colors etc
* Save plot objects
* Themes for reusing styles
* Numerous add-ons/extensions
* Nearly complete graphing solution

--

Not suitable for:

* 3D graphics

???

Why can't we just do everything is base plot? Of course, we could, but it's easier, consistent and more structured using `ggplot2`. There is bit of a learning curve, but once the code syntax and graphic building logic is clear, it becomes easy to plot a large variety of graphs.

---
name: gvb1

# `ggplot2` vs Base Graphics

.pull-left-50[
```{r,fig.height=4.5,fig.width=4}
hist(iris$Sepal.Length)
```
]

.pull-right-50[
```{r,fig.height=4,fig.width=4}
library(ggplot2)
ggplot(iris,aes(x=Sepal.Length))+
  geom_histogram(bins=8)
```
]

???

For simple graphs, the base plot seem to take minimal coding effort compared to a ggplot graph.

---
name: gvb2

# `ggplot2` vs Base Graphics

.pull-left-50[
```{r,fig.height=4.5,fig.width=4}
plot(iris$Petal.Length,iris$Petal.Width,
     col=c("red","green","blue")[iris$Species],
     pch=c(0,1,2)[iris$Species])
legend(x=1,y=2.5,
       legend=c("setosa","versicolor","virginica"),
       pch=c(0,1,2),col=c("red","green","blue"))
```
]

.pull-right-50[
```{r,fig.height=4,fig.width=5}
ggplot(iris,aes(Petal.Length,Sepal.Length,color=Species))+
  geom_point()
```
]

???

For anything beyond extremely basic plots, base plotting quickly become complex. More importantly, base plots do not have consistency in it's functions or plotting strategy.

---
name: gog
class: spaced

# Grammar Of Graphics

.pull-left-30[
![](data/slide_ggplot2/gog.jpg)
![](data/slide_ggplot2/gog.png)
]

--

.pull-right-70[
* **Data**: Input data
* **Geom**: A geometry representing data. Points, Lines etc
* **Aesthetic**: Visual characteristics of the geometry. Size, Color, Shape etc
* **Scale**: How visual characteristics are converted to display values
* **Statistics**: Statistical transformations. Counts, Means etc
* **Coordinates**: Numeric system to determine position of geometry. Cartesian, Polar etc
* **Facets**: Split data into subsets
]

???

`ggplot` was created by Hadley Wickham in 2005 as an implementation of Leland Wilkinson's book Grammar of Graphics.

Different graphs have always been considered as independent entities and also labelled differently such as barplots, scatterplots, boxplots etc. Each graph has it's own function and plotting strategy.

Grammar of graphics (GOG) tries to unify all graphs under a common umbrella. GOG brings the idea that graphs are made up of discrete components which can be mixed and matched to create any plot. This creates a consistent underlying framework to graphing.

---
name: syntax

# Building A Graph: Syntax

![](data/slide_ggplot2/syntax.png)

---
name: build-1

# Building A Graph

.pull-left-40[
```{r,fig.height=3.5,fig.width=3.5,eval=FALSE}
ggplot(iris)
```
]

.pull-right-50[
```{r,fig.height=3.5,fig.width=3.5,echo=FALSE}
data(iris)
ggplot(iris)
```
]

---
name: build-2

# Building A Graph

.pull-left-40[
```{r,fig.height=3.5,fig.width=3.5,eval=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width))
```
]

.pull-right-60[
```{r,fig.height=3.5,fig.width=3.5,echo=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width))
```
]

---
name: build-3

# Building A Graph

.pull-left-40[
```{r,fig.height=3.5,fig.width=3.5,eval=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width))+
  geom_point()
```
]

.pull-right-60[
```{r,fig.height=3.5,fig.width=3.5,echo=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width))+
  geom_point()
```
]

---
name: build-4

# Building A Graph

.pull-left-40[
```{r,fig.height=3.5,fig.width=3.5,eval=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width,
                colour=Species))+
  geom_point()
```
]

.pull-right-60[
```{r,fig.height=3.5,fig.width=3.5,echo=FALSE}
ggplot(iris,aes(x=Sepal.Length,
                y=Sepal.Width,
                colour=Species))+
  geom_point()
```
]

---
name: data-iris

# Data • `iris`

* Input data is always an R `data.frame` object


```{r,echo=FALSE}
iris %>%
  head(n=3) %>%
  kable("html",escape=F,align="c")
```

```{r}
str(iris)
```

???

It's a good idea to use `str()` to check the input dataframe to make sure that numbers are actually numbers and not characters, for example. Verify that factors are correctly assigned.

---
name: data-diamonds

# Data • `diamonds`

```{r,echo=FALSE}
head(diamonds,n=3) %>%
  na.omit() %>%
  kable("html",escape=F,align="c")
```

```{r}
str(diamonds)
```

???

R `data.frame` is a tabular format with rows and columns just like a spreadsheet. All items in a row or a column must be available or missing values filled in as NAs.

---
name: data-format

# Data • Format

* Transforming data into long or wide formats

```{r,comment=""}
iris %>% head(n=4)
```

```{r,comment=""}
iris %>% tidyr::pivot_longer(!Species,names_to="variable",values_to="value") %>%
         as.data.frame() %>% head(n=5)
```

???

The data must be cleaned up and prepared for plotting. The data must be 'tidy'. Columns must be variables and rows must be observations. The data can then be in wide or long format depending on the variables to be plotted.

---
name: geom

# Geoms

![geoms](data/slide_ggplot2/geoms.png)
--
```{r,eval=FALSE}
p <- ggplot(iris)
# scatterplot
p+geom_point(aes(x=Sepal.Length,y=Sepal.Width))
# barplot
p+geom_bar(aes(x=Sepal.Length))
# boxplot
p+geom_boxplot(aes(x=Species,y=Sepal.Width))
# search
help.search("^geom_",package="ggplot2")
```

???

Geoms are the geometric components of a graph such as points, lines etc used to represent data. The same data can be visually represented in different geoms. For example, points or bars. Mandatory input requirements change depending on geoms.

---
name: aes

# Aesthetics

* Aesthetic mapping vs aesthetic parameter

.pull-left-50[
```{r,fig.height=4,fig.width=5.5}
ggplot(iris)+
  geom_point(aes(x=Sepal.Length,
                 y=Sepal.Width,
                 size=Petal.Length,
                 alpha=Petal.Width,
                 shape=Species,
                 color=Species))
```
]

.pull-left-50[
```{r,fig.height=4,fig.width=4}
ggplot(iris)+
  geom_point(aes(x=Sepal.Length,
                 y=Sepal.Width),
                 size=2,
                 alpha=0.8,
                 shape=15,
                 color="steelblue")
```
]

???

Aesthetics are used to assign values to geometries. For example, a set of points can be a fixed size or can be different colors or sizes denoting a variable.

This would be an incorrect way to do it.

```
ggplot(iris)+
geom_point(aes(x=Sepal.Length,y=Sepal.Width,size=2)
```

---
name: aes-2

# Aesthetics

```{r,echo=TRUE,fig.height=4,fig.width=8}
x1 <- ggplot(iris) +
  geom_point(aes(x=Sepal.Length,y=Sepal.Width))+
  stat_smooth(aes(x=Sepal.Length,y=Sepal.Width))

x2 <- ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width))+
                      geom_point() + geom_smooth()

x1|x2
```

???

If the same aesthetics are used in multiple geoms, they can be moved to `ggplot()`.

---
name: multiple-geom

# Multiple Geoms

```{r,fig.height=4.8,fig.width=9}
ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width))+
      geom_point()+
      geom_line()+
      geom_smooth()+
      geom_rug()+
      geom_step()+
      geom_text(data=subset(iris,iris$Species=="setosa"),aes(label=Species))
```

???

Multiple geoms can be plotted one after the other. The order in which items are specified in the command dictates the plotting order on the actual plot.

In this case, the points appear over the lines.

```
ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width))+
      geom_point()+
      geom_line()+
```

while here the lines appear above the points.

```
ggplot(iris,aes(x=Sepal.Length,y=Sepal.Width))+
      geom_line()+
      geom_point()+
```

Each geom takes input from `ggplot()` inputs. If extra input is required to a geom, it can be specified additionally inside `aes()`.

`data` can be changed if needed for specific geoms.

---
name: scales-discrete-color

# Scales • Discrete Colors

* scales: position, color, fill, size, shape, alpha, linetype
* syntax: `scale_<aesthetic>_<type>`

<img src="data/slide_ggplot2/scales.png" alt="scales-syntax" style="width:50%;">

--

.pull-left-50[
```{r,fig.height=2.7,fig.width=4}
p <- ggplot(iris)+geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width,color=Species))
p
```
]

--

.pull-right-50[
```{r,fig.height=2.7,fig.width=4}
p + scale_color_manual(
     name="Manual",
     values=c("#5BC0EB","#FDE74C","#9BC53D"))
```
]

???

Scales are used to control the aesthetics. For example the aesthetic color is mapped to a variable `x`. The palette of colors used, the mapping of which color to which value, the upper and lower limit of the data and colors etc is controlled by scales.

---
name: scales-continuous-color

# Scales • Continuous Colors

* In RStudio, type `scale_`, then press **TAB**

--

.pull-left-50[
```{r,fig.height=4,fig.width=5}
p <- ggplot(iris)+
      geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width,
      shape=Species,color=Petal.Length))
p
```
]

--

.pull-right-50[
```{r,fig.height=4,fig.width=5}
p +
scale_color_gradient(name="Pet Len",
  breaks=range(iris$Petal.Length),
  labels=c("Min","Max"),
  low="black",high="red")

```
]

???

Continuous colours can be changed using `scale_color_gradient()` for two colour gradient. Any number of breaks and colours can be specified using `scale_color_gradientn()`.  

---
name: scales-shape

# Scales • Shape

.pull-left-50[
```{r,fig.height=4,fig.width=5}
p <- ggplot(iris)+
      geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width,
      shape=Species,color=Species))
p
```
]

--

.pull-right-50[
```{r,fig.height=4,fig.width=5}
p +
scale_color_manual(name="New",
   values=c("blue","green","red"))+
scale_shape_manual(name="Bla",values=c(0,1,2))

```
]

???

Shape scale can be adjusted using `scale_shape_manual()`. Multiple mappings for the same variable groups legends.

---
name: scales-axis

# Scales • Axes

* scales: x, y
* syntax: `scale_<axis>_<type>`
* arguments: name, limits, breaks, labels

--

.pull-left-50[
```{r,fig.height=4,fig.width=5}
p <- ggplot(iris)+
      geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width))
p
```
]

--

.pull-right-50[
```{r,fig.height=4,fig.width=5}
p + scale_color_manual(name="New",
   values=c("blue","green","red"))+
scale_x_continuous(name="Sepal Length",
        breaks=seq(1,8),limits=c(3,5))
```
]

???

The x and y axes are also controlled by scales. The axis break points, the break point text and limits are controlled through scales.

When setting limits using `scale_`, the data outside the limits are dropped. Limits can also be set using `lims(x=c(3.5))` or `xlim(c(3,5))`. When mapping, `coord_map()` or `coord_cartesian()` is recommended for setting limits.

---
name: facet-wrap

# Facets • `facet_wrap`

* Split to subplots based on variable(s)
* Facetting in one dimension

--

.pull-left-50[
```{r,fig.height=4.5,fig.width=5}
p <- ggplot(iris)+
      geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width,
                     color=Species))
p
```
]

--

.pull-right-50[
```{r,fig.height=2.2,fig.width=4.5}
p + facet_wrap(~Species)
```

```{r,fig.height=2.4,fig.width=4.5}
p + facet_wrap(~Species,nrow=3)
```
]

???

`facet_wrap` is used to split a plot into subplots based on the categories in one or more variables.

---
name: facet-grid

# Facets • `facet_grid`

* Facetting in two dimensions

.pull-left-50[
```{r,fig.height=3.5,fig.width=5}
p <- diamonds %>%
     ggplot(aes(carat,price))+
     geom_point()
p + facet_grid(~cut+clarity)
```
]

--

.pull-left-50[
```{r,fig.height=4.2,fig.width=5.2}
p + facet_grid(cut~clarity)
```
]

???

`facet_grid` is also used to split a plot into subplots based on the categories in one or more variables. `facet_grid` can be used to create a matrix-like grid of two variables.

---
name: coordinate

# Coordinate Systems

![](data/slide_ggplot2/coordinate.png)

* `coord_cartesian(xlim=c(2,8))` for zooming in
* `coord_map` for controlling limits on maps
* `coord_polar`

.pull-left-50[
```{r,fig.height=3.4,fig.width=4}
p <- ggplot(iris,aes(x="",y=Petal.Length,fill=Species))+
  geom_bar(stat="identity")
p
```
]

???

The coordinate system defines the surface used to represent numbers. Most plots use the cartesian coordinate sytem. Pie charts for example, is a polar coordinate projection of a cartesian barplot. Maps for example can have numerous coordinate systems called map projections. For example; UTM coordinates.

--

.pull-right-50[
```{r,fig.height=3.9,fig.width=4.4}
p+coord_polar("y",start=0)
```
]

---
name: theme

# Theme

* Modify non-data plot elements/appearance
* Axis labels, panel colors, legend appearance etc
* Save a particular appearance for reuse
* `?theme`

--

.pull-left-50[
```{r,fig.height=4,fig.width=4}
ggplot(iris,aes(Petal.Length))+
  geom_histogram()+
  facet_wrap(~Species,nrow=2)+
  theme_grey()
```
]

--

.pull-right-50[
```{r,fig.height=4,fig.width=4}
ggplot(iris,aes(Petal.Length))+
  geom_histogram()+
  facet_wrap(~Species,nrow=2)+
  theme_bw()
```
]

???

Themes allow to modify all non-data related components of the plot. This is the visual appearance of the plot. Examples include the axes line thickness, the background color or font family.

---
name: theme-legend

# Theme • Legend

```{r,fig.height=3,fig.width=4}
p <- ggplot(iris)+
      geom_point(aes(x=Sepal.Length,
                     y=Sepal.Width,
                     color=Species))
```

.pull-left-50[
```{r,fig.height=4.3,fig.width=4.3}
p + theme(legend.position="top")
```
]

.pull-right-50[
```{r,fig.height=4.3,fig.width=4.3}
p + theme(legend.position="bottom")
```
]

---
name: theme-text

# Theme • Text

```{r,eval=FALSE}
element_text(family=NULL,face=NULL,color=NULL,size=NULL,hjust=NULL,
             vjust=NULL, angle=NULL,lineheight=NULL,margin = NULL)
```

```{r,echo=FALSE}
p <- diamonds %>%
      filter(cut=="Fair"|cut=="Good",color=="D"|color=="E") %>%
      droplevels() %>%
      ggplot(aes(carat,price,alpha=color,shape=cut))+
            geom_point()+
            labs(title="Title",subtitle="subtitle")+
            facet_grid(cut~color)
```

```{r}
p <- p + theme(
    axis.title=element_text(color="#e41a1c"),
    axis.text=element_text(color="#377eb8"),
    plot.title=element_text(color="#4daf4a"),
    plot.subtitle=element_text(color="#984ea3"),
    legend.text=element_text(color="#ff7f00"),
    legend.title=element_text(color="#ffff33"),
    strip.text=element_text(color="#a65628")
)
```

```{r,fig.height=4,fig.width=10,echo=FALSE}
dfr <- data.frame(value=rep(1,7),label=c("axis.title","axis.text","plot.title","plot.subtitle","legend.text","legend.title","strip.text"),stringsAsFactors=FALSE) %>%
  mutate(label=factor(label,levels=c("axis.title","axis.text","plot.title","plot.subtitle","legend.text","legend.title","strip.text")))

q <- ggplot(dfr,aes(x=label,y=value,fill=label))+
  geom_bar(stat="identity")+
  labs(x="",y="")+
  coord_flip()+
  scale_fill_manual(values=c("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628"))+
  theme_minimal(base_size=20)+
  theme(
    legend.position="none",
    axis.text.x=element_blank(),
    axis.ticks=element_blank(),
    panel.grid=element_blank())

p|q
```

---
name: theme-rect

# Theme • Rect

```{r,eval=FALSE}
element_rect(fill=NULL,color=NULL,size=NULL,linetype=NULL)
```

```{r,echo=FALSE}
p <- diamonds %>%
      filter(cut=="Fair"|cut=="Good",color=="D"|color=="E") %>%
      droplevels() %>%
      ggplot(aes(carat,price,alpha=color,shape=cut))+
            geom_point()+
            labs(title="Title",subtitle="subtitle")+
            facet_grid(cut~color)
```

```{r}
p <- p + theme(
    plot.background=element_rect(fill="#b3e2cd"),
    panel.background=element_rect(fill="#fdcdac"),
    panel.border=element_rect(fill=NA,color="#cbd5e8",size=3),
    legend.background=element_rect(fill="#f4cae4"),
    legend.box.background=element_rect(fill="#e6f5c9"),
    strip.background=element_rect(fill="#fff2ae")
)
```

```{r,fig.height=3.8,fig.width=10,echo=FALSE}
dfr <- data.frame(value=rep(1,6),label=c("plot.background","panel.background","panel.border","legend.background","legend.box.background","strip.background"),stringsAsFactors=FALSE) %>%
  mutate(label=factor(label,levels=c("plot.background","panel.background","panel.border","legend.background","legend.box.background","strip.background")))

q <- ggplot(dfr,aes(x=label,y=value,fill=label))+
  geom_bar(stat="identity")+
  labs(x="",y="")+
  coord_flip()+
  scale_fill_manual(values=c("#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae"))+
  theme_minimal(base_size=20)+
  theme(
    legend.position="none",
    axis.text.x=element_blank(),
    axis.ticks=element_blank(),
    panel.grid=element_blank())

p|q
```

---
name: theme-save

# Theme • Reuse

```{r,echo=FALSE}
p <- diamonds %>%
      filter(cut=="Fair"|cut=="Good"|cut=="Very Good") %>%
      droplevels() %>%
      ggplot(aes(carat,price,color=cut))+
            geom_point()
```

```{r,echo=TRUE}
newtheme <- theme_bw() + theme(
  axis.ticks=element_blank(),
  panel.background=element_rect(fill="white"),
  panel.grid.minor=element_blank(),
  panel.grid.major.x=element_blank(),
  panel.grid.major.y=element_line(size=0.3,color="grey90"),
  panel.border=element_blank(),
  legend.position="top",
  legend.justification="right"
)
```

.pull-left-50[
```{r,echo=TRUE,fig.height=3.5,fig.width=5}
p
```
]

.pull-right-50[
```{r,fig.height=3.3,fig.width=4.5}
p + newtheme
```
]

---
name: position

# Position

```{r,echo=FALSE}
USArrests %>% head(n=3)
```

```{r}
us <- USArrests %>% mutate(state=rownames(.)) %>% slice(1:4) %>%
                    gather(key=type,value=value,-state)
p <- ggplot(us,aes(x=state,y=value,fill=type))
```

--

.pull-left-50[
```{r,fig.height=3.3,fig.width=4.5}
p + geom_bar(stat="identity",position="stack")
```
]

--

.pull-right-50[
```{r,fig.height=3.3,fig.width=4.5}
p + geom_bar(stat="identity",position="dodge")
```
]

---
name: save

# Saving plots

```{r,eval=FALSE}
p <- ggplot(iris,aes(Petal.Length,Sepal.Length,color=Species))+
  geom_point()
```

* `ggplot2` plots can be saved just like base plots  

```{r,eval=FALSE}
png("plot.png",height=5,width=7,units="cm",res=200)
print(p)
dev.off()
```

* `ggplot2` package offers a convenient function  

```{r,eval=FALSE}
ggsave("plot.png",p,height=5,width=7,units="cm",dpi=200,type="cairo")
```

* Use `type="cairo"` for nicer anti-aliasing  
* Note that default units in `png` is pixels while in `ggsave` it's inches  

---
name: extension
class: spaced

# Extensions

* [**gridExtra**](https://cran.r-project.org/web/packages/gridExtra/index.html): Extends grid graphics functionality
* [**ggpubr**](http://www.sthda.com/english/rpkgs/ggpubr/): Useful functions to prepare plots for publication  
* [**cowplot**](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html): Combining plots  
* [**ggthemes**](https://cran.r-project.org/web/packages/ggthemes/vignettes/ggthemes.html): Set of extra themes  
* [**ggthemr**](https://github.com/cttobin/ggthemr): More themes  
* [**ggsci**](https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html): Color palettes for scales  
* [**ggrepel**](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html): Advanced text labels including overlap control  
* [**ggmap**](https://github.com/dkahle/ggmap): Dedicated to mapping  
* [**ggraph**](https://github.com/thomasp85/ggraph): Network graphs  
* [**ggiraph**](http://davidgohel.github.io/ggiraph/): Converting ggplot2 to interactive graphics  

---
name: help
class: spaced

# Help

* [**ggplot2 official reference**](http://ggplot2.tidyverse.org/reference/)  
* [**The R cookbook**](http://www.cookbook-r.com/)  
* [**StackOverflow**](https://stackoverflow.com/)  
* [**RStudio Cheatsheet**](https://www.rstudio.com/resources/cheatsheets/)  
* [**r-statistics Cheatsheet**](http://r-statistics.co/ggplot2-cheatsheet.html)  
* [**ggplot2 GUI**](https://site.shinyserver.dck.gmw.rug.nl/ggplotgui/)  
* Numerous personal blogs, r-bloggers.com etc.  

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end-slide
class: end-slide, middle
count: false

# Thank you. Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
rmarkdown::render("ggplot_presentation.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("ggplot_presentation.html",output="ggplot_presentation.pdf")
```

<!--chapter:end:slide_ggplot2.Rmd-->

---
title: "Reading (and writing) data in R"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak"
keywords: "bioinformatics, course, scilifelab, nbis, R"
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, width=60)
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
#library(mkteachr)
```

---
name: reading_data

# Reading data

--

* Reading data is one of the most consuming and most cumbersome aspects of bioinformatics...

--

* R provides a number of ways to read and write data stored on different media (file, database, url, twitter, Facebook, etc.) and in different formats.

--

* Package `foreign` contains a number of functions to import less common data formats.

---
name: reading_tables

# Reading tables

Most often, we will use the `read.table()` function. It is really, really flexible and nice way to read your data into a data.frame structure with rows corresponding to observations and columns to particular variables.  

The function is declared in the following way:  

```
read.table(file, header = FALSE, sep = "", quote = "\"'",
           dec = ".", numerals = c("allow.loss", "warn.loss", "no.loss"),
           row.names, col.names, as.is = !stringsAsFactors,
           na.strings = "NA", colClasses = NA, nrows = -1,
           skip = 0, check.names = TRUE, fill = !blank.lines.skip,
           strip.white = FALSE, blank.lines.skip = TRUE,
           comment.char = "#",
           allowEscapes = FALSE, flush = FALSE,
           stringsAsFactors = default.stringsAsFactors(),
          fileEncoding = "", encoding = "unknown", text, skipNul = FALSE)*
```

---
name: read_table_params

# `read.table` parameters

You can read more about the *read.table* function on its man page, but the most important arguments are:

* file &ndash; the path to the file that contains data,
* header &ndash; a logical indicating whether the first line of the file contains variable names,
* sep &ndash; a character determining variable delimiter, e.g. comma for csv files,
* quote &ndash; a character telling R which character surrounds strings,
* dec &ndash; acharacter determining the decimal separator,
* row/col.names &ndash; vectors containing row and column names,
* na.strings &ndash; a character used for missing data,
* nrows &ndash; how many rows should be read,
* skip &ndash; how many rows to skip,
* as.is &ndash; a vector of logicals or numbers indicating which columns shall not be converted to factors,
* fill &ndash; add NA to the end of shorter rows,
* stringsAsFactors &ndash; a logical. Rather self explanatory.

---
name: read_table_sibs

# `read.table` and its siblings  

The `read.table` function has some siblings, functions with particular arguments pre-set to a specific value to spare some time:

* `read.csv()` and `read.csv2()` with comma and semicolon as default `sep` and dot and comma as `dec` respectively,
* `read.delim()` and `read.delim2()` for reading tab-delimited files.

We, however, most often use the canonical `read.table()` as it is the most flexible one.

---
name: read_table_example

# `read.table` &mdash; example use

```{r read.table, echo=T}
tab <- read.table(file = 'data/slide_loading_data/2014-04-07_phenos2.csv',
                  sep = ' ',
                  header = T)
tab[1:5, 1:3]
class(tab$reg_no)
```

---
name: handling_errors

# What if you encounter errors?

* StackOverflow,
* Google &ndash; just type R and copy the error you got without your variable names,
* open the file &ndash; has the header line the same number of columns as the first line?
* in Terminal (on Linux/OsX) you can type some useful commands.

--

# Useful commands for debugging

--

* `cat phenos.txt | awk -F';' '{print NF}'` prints the number of words in each row. `-F';'` says that semicolon is the delimiter,

--

* `head -n 5 phenos.txt` prints the 5 first lines of the file,

--

* `tail -n 5 phenos.txt` prints the 5 last lines of the file,

--

* `head -n 5 phenos.txt | tail -n 2` will print lines 4 and 5...

--

* `wc -l phenos.txt` will print the number of lines in the file

--

* `head -n 2 phenos.txt > test.txt` will write the first 2 lines to a new file

--

If it still does not give you a clue &mdash; just try to load first line of the file.  

--

If this still did not help, split the file in two equal-size parts. Check which part gives the error. Split this part into halves and check which 1/4 gives the error... It is faster than you think!

---
name: writing

# Writing with `write.table()`

`read.table()` has its counterpart, the `write.table()` function (as well ass its siblings, like write.csv()). You can read more about it in the documentation, let us show some examples:

```{r write.table, echo=T, eval=F}
vec <- rnorm(10)
write.table(vec, '') # write to screen
write.table(vec, file = 'vector.txt')
# write to the system clipboard, handy!
write.table(vec, 'clipboard', col.names=F,
            row.names=F)
# or on OsX
clip <- pipe("pbcopy", "w")                       
write.table(vec, file=clip)                               
close(clip)
# To use in a spreadsheet
write.csv(vec, file = 'spreadsheet.csv')
```

---
name: write_big_data

# Writing big data

* HINT: `write.table()` is rather slow on big data &ndash; it checks types for every column and row and does separate formatting to each. If your data consists of only one type of data, convert it to a matrix using `as.matrix` before you write it!  

* You may want to use function `scan()` that reads files as vectors. The content does not have to be in the tabular form. You can also use scan to read data from keyboard: `typed.data <- scan()`

* If data are written as fixed-width fields, use the `read.fwf()` function.

* Also check out the `readLines()` function that enables you to read data from any stream.

---
name: read_xls_matlab

# Read data in xls/xlsx and Matlab

```{r xls, eval=F, echo=T}
library(readxl)
data <- readxl::read_xlsx('myfile.xlsx')
```

```{r matlab, eval=F, echo=T}
library(R.matlab)
data <- R.matlab::readMat("mydata.mat")
```

---
name: remote_data

# Working with remote data

```{r url.data, eval=F, cache=T, echo=T}
url <- 'https://en.wikipedia.org/wiki/List_of_countries_by_average_wage'
conn <- url(url, 'r')
raw.data <- readLines(conn)
raw.data[1:3]
```

But data is often tabularized...

```{r url.data.2, eval=F, cache=T, echo=T}
library(rvest)
html <- read_html(url)
tables <- html_nodes(html, 'table')
data <- html_table(tables[4])[[1]]
data[1:5, ]
```

---
name: databases

# Working with databases

It is also relatively easy to work with different databases. We will focus on MySQL and present only one example that uses the *RMySQL* package (check also *RODBC* and *RPostgreSQL*).
```{r db, echo=T, eval=F}
library(RMySQL)
db.conn <- dbConnect(MySQL(), user='me',
                     password='qwerty123',
                     dbname='genes',
                     host='127.0.0.237')
query <- dbSendQuery(db.conn, 'SELECT * FROM table7')
data <- fetch(query, n = - 1)
```

---
name: capabilities

# Capabilities

If you are getting some errors, e.g. trying to connect to a url, you may check whether your system (and R) support particular type of file or connection:
```{r capabil, echo=T, size='tiny'}
capabilities()
```

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# See you at the next lecture!

```{r, echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_loading_data.Rmd-->

---
title: "Variables, Data types & Operators"
subtitle: "Elements of the R language"
author: "Marcin Kierczak"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, width=60)
```

```{r,include=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
#library(mkteachr)
```

---
name: intro

# Introduction

Today, we will talk about various elements of a programming language and see how they are realized in R.

# Contents

- **variables and their types**
- **operators**
- vectors
- numbers as vectors
- strings as vectors
- matrices
- lists
- data frames
- objects
- repeating actions: iteration and recursion
- decision taking: control structures
- functions in general
- variable scope
- core functions

---
name: variables

# Variables

- Creating a variable is simply assigning a name to some structure that stores data...

```{r variables,echo=TRUE,size='Tiny'}
7 + 9
a <- 7
a
b <- 9
b
c <- a + b
c
```

---
# Variables cted.

We are not constrained to numbers...

```{r variables2,echo=TRUE}
text1 <- 'a'
text2 <- 'qwerty'
text1  
text2
```

# Is `<-` equivalent to `=`? Which one shall I use?

- `val <- 3`, `val = 3` and `3 -> val` are three equivalent ways of assigning in R, But, it's best to use only `<-` to avoid possible confusion. The equal sign `=` should be used when setting function arguments ie; `f(a = 3)`.

---
name: variables_naming

# Variables &mdash; naming conventions

- How to write variable names?
- What is legal/valid?
- What is a good style?

--

A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number.  

--

Names such as ".2way" are not valid, and neither are the so-called *reserved words*.  

--

# Reserved words

- `if, else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_`  

- and you also **cannot** use: `c, q, t, C, D, I`

- and you **should not** use: `T, F`

---
name: variables_good_style

# Variables &mdash; good style

- So, how to name variables?

- make them informative, e.g. `genotypes` instead of `fsjht45jkhsdf4`,

--

- use consistent notation across your code &ndash; the same *naming convention*,

--

- camelNotation vs. dot.notation vs. dash_notation,

--

- do not `give_them_too_long_names`,

--

- in the dot notation avoid `my.variable.2`, use `my.variable2` instead,

--

- there are certain customary names:
    - `tmp` - for temporary variables;
    - `cnt` for counters;
    - `i,j,k` within loops,
    - `pwd` - for password...

---
name: data_types_1

# Variables have types

A *numeric* stores numbers of different *types*:

```{r variable.types1,echo=TRUE}
x <- 41.99 # assign 41.99 to x
typeof(x)
```

---
name: class_type_mode

# Classes, types, and modes

- `class` what type of object is it for R,
- `typeof()` what R thinks it is,
- `mode()` how S language would see it (backward compatibility),
- `storage.mode()` how is it stored in the memory; useful when talking to C or Java,

```{r class,echo=TRUE,eval=TRUE}
x <- 1:3
class(x)
typeof(x)
mode(x)
storage.mode(x)
```

---
name: type_casting

# Type casting

By default, any *numeric* is stored as *double* !

```{r variable types2,echo=TRUE}
y=12 # now assign an integer value to y
class(y) # still numeric
typeof(y) # an integer, but still a double!
```

But we can explicitly **cast it** to integer:

```{r variable types3,echo=TRUE}
x <- as.integer(x) # type conversion, casting
typeof(x)
class(x)
is.integer(x)
```

> We need **casting** because sometimes a function requires data of some type!

---
name: casting2

# More on type casting

Be careful when casting!

```{r careful.casting,echo=TRUE}
pi <- 3.1415926536 # assign approximation of pi to pi
pi
pi <- as.integer(pi) # not-so-careful casting
pi
pi <- as.double(pi) # trying to rescue the situation
pi
```

Casting is not rounding!

```{r casting.not.rounding,echo=TRUE}
as.integer(3.14)
as.integer(3.51)
```

---
name: ceiling_floor

# Ceiling, floor and a round corner

```{r casting.not.rounding2,echo=TRUE}
floor(3.51) # floor of 3.51
ceiling(3.51) # ceiling of 3.51
round(3.51, digits=1) # round to one decimal
```

---
name: coercion

# What happens if we cast a string to a number

```{r casting.string,echo=TRUE}
as.numeric('4.5678')
as.double('4.5678')
as.numeric('R course is cool!')
```

---
name: some_special_values

# Special values

```{r special.values,echo=TRUE}
-1/0  # Minus infinity
1/0 # Infinity
```

and also:

```{r special.values2,echo=TRUE}
112345^67890  # Also infinity for R
1/2e78996543  # Zero for R
Inf - Inf # Not a Number
```

---
name: cplx_numbers

# Complex number type

Core R supports complex numbers.

```{r cplx,echo=TRUE}
z = 7 + 4i # create a complex number
z
class(z)
typeof(z)
is.complex(z)
```

```{r cplx2,echo=TRUE}
sqrt(-1) # not treated as cplx number
sqrt(-1 + 0i) # now a proper cplx number
sqrt(as.complex(-1)) # an alternative way
```

---
name: logical_type

# Logical type

```{r logical.type,echo=TRUE}
a <- 7 > 2
b <- 2 >= 7
a
b
class(a)
typeof(a)
```

R has three logical values: TRUE, FALSE and NA.

```{r logical.type2,echo=TRUE}
x <- c(TRUE, FALSE, NA)
names(x) <- as.character(x)
and_truth_table <- outer(x, x, "&") # AND table
```
```{r logical.DT, echo=FALSE}
kableExtra::kable(and_truth_table)
```

---
name: logical_cted

# Logical type cted.

```{r logical.type3,echo=TRUE}
x <- TRUE
x
x <- T # also valid
x
is.logical(x)
typeof(x)
```

- Observe that in R the logical type is also a numeric!

```{r logical.as.number,echo=TRUE}
x <- TRUE
y <- FALSE
x + y
2 * x
x * y
```

---
name: logical_joke

# A trap set up for you

Never ever use variable names as T or F. Why?

```{r TFtrap,echo=TRUE}
F <- T
T
F
```
Maybe applicable in politics, but not really in science...

---
name: character_type

# Character type

It is easy to work with characters and strings:

```{r char.type,echo=TRUE}
character <- 'c'
text <- 'This is my first sentence in R.'
text
character
class(character)
typeof(text) # also of 'character' type
```

---
name: character_type_2

# Character type

```{r char.type2,echo=TRUE}
number <- 3.14
number.text <- as.character(number) # cast to char
number.text
class(number.text)
as.numeric(number.text) # and the other way round
```

---
name: basic_string_ops

# Basic string operations

```{r basic.string,echo=TRUE}
  text1 <- "John had a yellow "
  text2 <- "submarine"
  result <- paste(text1, text2, ".", sep='')
  result
  sub("submarine", "cab", result)
  substr(result, start=1, stop=5)
```

---
name: basic_printing

# Basic printing

```{r basic.printing,echo=TRUE}
  txt <- "blue"
  (txt <- 'red')
  val <- 345.78
  sprintf("The weight of a %s ball is  %g g", txt, val)
```

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# See you at the next lecture!

```{r, echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_elements_1.Rmd-->

---
title: "Introduction To Programming in R (2)"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak, Sebastian DiLorenzo"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---
exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
```

---
name: contents

## Contents of the lecture

- variables and their types
- operators
- **vectors**
- **numbers as vectors**
- **strings as vectors**
- matrices
- lists
- data frames
- objects
- repeating actions: iteration and recursion
- decision taking: control structures
- functions in general
- variable scope
- core functions

---
name: cplx_data_str

## Complex data structures
Using the previously discussed basic data types (`numeric`, `integer`, `logical` and `character`) one can construct more complex data structures:

--

dim | Homogenous | Heterogenous
----|------------|-----------------
0d  | n/a        | n/a
1d  | vectors    | list
2d  | matrices   | data frame
nd  | arrays     | n/a  

- factors &ndash; special type

---
name: atomic_vectors

## Atomic vectors
An *atomic vector*, or simply a *vector* is a one dimensional data structure (a sequence) of elements of the same data type. Elements of a vector are oficially called *components*, but we will just call them *elements*.

We construct vectors using core function `c()` (construct).
```{r vector, echo=T} 
vec <- c(1,2,5,7,9,27,45.5)
vec
```
In R, even a single number is a one-element vector. You have to get used to think in terms of vectors...

---
name: atomic_vectors2

## Atomic vectors cted.
You can also create empty/zero vectors of a given type and length:
```{r vec.empty, echo=T}
vector('integer', 5) # a vector of 5 integers
vector('character', 5)
character(5) # does the same
logical(5) # same as vector('logical', 5)
```

---
name: combining_vectors

## Combining two or more vectors
Vectors can easily be combined:
```{r vec.comb, echo=T}
v1 <- c(1,3,5,7.56)
v2 <- c('a','b','c')
v3 <- c(0.1, 0.2, 3.1415)
c(v1, v2, v3)
```
Please note that after combining vectors, all elements became character. It is called a *coercion*.

---
name: basic_vect_arithm

## Basic vector arithmetics
```{r vec.artihmetics, echo=T}
v1 <- c(1, 2, 3, 4)
v2 <- c(7, -9, 15.2, 4)
v1 + v2 # addition
v1 - v2 # subtraction
v1 * v2 # scalar multiplication
v1 / v2 # division
```

---
name: recycling_rule

## Vectors &ndash; recycling rule
```{r vec.recycling, echo=T}
v1 <- c(1, 2, 3, 4, 5)
v2 <- c(1, 2)
v1 + v2
```
Values in the shorter vector will be **recycled** to match the length of the longer one: v2 <- c(1, 2, 1, 2, 1)

---
name: vec_indexing

## Vectors &ndash; indexing
We can access or retrieve particular elements of a vector by using the [] notation:
```{r vec.indexing, echo=T}
vec <- c('a', 'b', 'c', 'd', 'e')
vec[1] # the first element
vec[5] # the fifth element
vec[-1] # remove the first element
```

---
name: vec_indexing2

## Vectors &ndash; indexing cted.
And what happens if we want to retrieve elements outside the vector?
```{r vec.index.beyond, echo=T}
vec[0] # R counts elements from 1
vec[78] # Index past the length of the vector
```
Note, if you ask for an element with index lower than the index of the first element, you will het an empty vector of the sme type as the original vector.
If you ask for an element beyond the vector's length, you get an NA value.

---
name: vec_indexing3

## Vectors &ndash; indexing cted.
You can also retrieve elements of a vector using a vector of indices:
```{r vec.index.vec, echo=T}
vec <- c('a', 'b', 'c', 'd', 'e')
vec.ind <- c(1,3,5)
vec[vec.ind]
```

--

Or even a logical vector:
```{r vec.index.vec.log, echo=T}
vec <- c('a', 'b', 'c', 'd', 'e')
vec.ind <- c(TRUE, FALSE, TRUE, FALSE, TRUE)
vec[vec.ind]
```

---
name: vec_indexing_names

## Vectors &ndash; indexing using names
You can name elements of your vector:
```{r vec.index.names, echo=T}
vec <- c(23.7, 54.5, 22.7)
names(vec) # by default there are no names
names(vec) <- c('sample1', 'sample2', 'sample3')
vec[c('sample2', 'sample1')]
```

---
name: vec_rem_elem

## Vectors &ndash; removing elements
You can return a vector without certain elements:
```{r vec.rm, echo=T}
vec <- c(1, 2, 3, 4, 5)
vec[-5] # without the 5-th element
vec[-(c(1,3,5))] # withoutelements 1, 3, 5
```

---
name: vec_conditions

## Vectors indexing &ndash; conditions
Also logical expressions are allowed in indexing:
```{r vec.index.cond, echo=T}
vec <- c(1, 2, 3, 4, 5)
vec < 3 # we can use the value of this logical comparison
vec[vec < 3]# Et voila!
```

---
name: vec_more_ops

## Vectors &ndash; more operations
You can easily reverse a vector:
```{r vec.rev, echo=T}
vec <- c(1, 2, 3, 4, 5)
rev(vec)
```
You can generate vectors of subsequent numbers using `:`, e.g.:
```{r vec.seq.gen, echo=T}
v <- c(5:7)
v
v2 <- c(3:-4)
v2
```

---
name: vec_size

## Vectors &ndash; size
To get the size of a vector, use `length()`:
```{r vec.len, echo=T}
vec <- c(1:78)
length(vec)
```

---
name: vec_subst_elem

## Vectors &ndash; substitute element
To substitute an element in a vector simply:
```{r vec.subst, echo=T}
vec <- c(1:5)
vec
vec[3] <- 'a' # Note the coercion!
vec 
```

--

To insert 'a' at, say, the 2nd position:
```{r vec.ins, echo=T}
c(vec[1], 'a', vec[2:length(vec)])
```

---
name: vec_alter_len

## Vectors &ndash; changing the length
What if we write past the vectors last element?
```{r vec.chlen, echo=T}
vec <- c(1:5)
vec
vec[9] <- 9
vec 
```

---
name: vec_count_vals

## Vectors &ndash; counting values
One may be interested in the count of particular values:
```{r vec.table, echo=T}
vec <- c(1:5, 1:4, 1:3) # a vector with repeating values
table(vec) # table of counts
tab <- table(vec)/length(vec) # table of freqs.
round(tab, digits=3) # and let's round it
```

---
name: vec_sorting

## Vectors &ndash; sorting
To sort values of a vector:
```{r vec.sort, echo=T}
vec <- c(1:5, NA, NA, 1:3)
sort(vec) # oops, NAs got lost
sort(vec, na.last = TRUE)
sort(vec, decreasing = TRUE) # in a decreasing order
```

---
name: seq

## Sequences of numbers
R provides also a few handy functions to generate sequences of numbers:
```{r seq, echo=T}
c(1:5, 7:10) # the ':' operator
(seq1 <- seq(from=1, to=10, by=2))
(seq2 <- seq(from=11, along.with = seq1))
seq(from=10, to=1, by=-2)
```

---
name: printing_brackets

## A detour &ndash; printing with `()`
Note what we did here, if you enclose the expression in `()`, the result of assignment will be also printed:

```{r assignprint, echo=T}
seq1 <- seq(from = 1, to = 5)
seq1 # has to be printed explicitly
```
while:

--

```{r assignprint2, echo=T}
(seq2 <- seq(from = 5, to = 1)) # will print automatically
```

---
name: seq2

## Back to sequences
One may also wish to repeat certain value or a vector n times:
```{r rep, echo=T}
rep('a', times=5)
rep(1:5, times=3)
rep(seq(from=1, to=3, by=2), times=2)
```

---
name: random_seq

## Sequences of random numbers
There is also a really useful function `sample()` that helps with generating sequences of random numbers:

```{r sample, echo=T}
# simulate casting a fair dice 10x
sample(x = c(1:6), size=10, replace = T) 
# make it unfair, it is loaded on '3'
myprobs = rep(0.15, times = 6)
myprobs[3] <- 0.25 # a bit higher probability for '3'
sample(x = c(1:6), size = 10, replace = T, prob=myprobs)
```

---
name: simulate_dice

## Fair vs. loaded dice
Now, let us see how this can be useful. We need more than 10 results. Let's cast our dices 10,000 times and plot the freq. distribution.
```{r dices, echo=T}
# simulate casting a fair dice 10x
fair <- sample(x = c(1:6), size=10e3, replace = T) 
unfair <- sample(x = c(1:6), size=10e3, replace = T, 
                 prob = myprobs)
```

---
name: simulate_dice2

## Fair vs. loaded dice &ndash; the result
```{r dices.pic, fig=T, fig.height=4}
t1 <- table(fair)/length(fair)
t2 <- table(unfair)/length(unfair)
plot(0,0,type="n",xlim=c(1,6.0),ylim=c(0,.3),xlab="x",ylab="freq",bty='n', las=1)
grid()
points(1:6, t1, col="olivedrab")
points(1:6, t2, col="slateblue")
legend('topleft', legend = c('fair','unfair'), col = c('olivedrab', 'slateblue'),pch = 15, border = NULL, bty='n')
```

---
name: more_on_sample

## Sample &ndash; one more use
The sample function has one more interesting feature, it can be used to randomize order of already created vectors:
```{r sample.shuffle, echo=T}
mychars <- c('a', 'b', 'c', 'd', 'e', 'f')
mychars
sample(mychars)
sample(mychars)
```

---
name: vec_adv

## Vectors/sequences &ndash; more advanced operations
```{r vec.adv.oper, echo=T}
v1 <- sample(1:5, size = 4)
v1
max(v1) # max value of the vector
min(v1) # min value
sum(v1) # sum all the elements
```

---
name: vec_adv2

## Vectors/sequences &ndash; more advanced operations 2
```{r vec.adv.oper2, echo=T}
v1
diff(v1) # diff. of element pairs
cumsum(v1) # cumulative sum
prod(v1) # product of all elements
```

---
name: vec_adv3

## Vectors/sequences &ndash; more advanced operations 3
```{r vec.adv.oper3, echo=T}
v1
cumprod(v1) # cumulative product
cummin(v1) # minimum so far (up to i-th el.)
cummax(v1) # maximum up to i-th element
```

---
name: vec_pairwise_comp

## Vectors/sequences &ndash; pairwise comparisons
```{r make.vec2}
v2 <- sample(1:5, size=4)
```
```{r vec.adv.pairwise, echo=T}
v1
v2
v1 <= v2 # direct comparison
pmin(v1, v2) # pairwise min
pmax(v1, v2) # pairwise max
```

---
name: vec_order_rank

## Vectors/sequences &ndash; `rank()` and `order()`
rank() and order() are a pair of inverse functions.  
```{r vec.adv.rank.order, echo=T}
v1 <- c(1, 3, 4, 5, 3, 2)
rank(v1) # show rank of each value (min has rank 1)
order(v1) # order of indices for a sorted vector
v1[order(v1)]
sort(v1)
```

---
name: factors

## Factors
To work with **nominal** values, R offers a special data type, a *factor*:
```{r factor, echo=T}
vec <- c('giraffe', 'donkey', 'liger', 
         'liger', 'giraffe', 'liger')
vec.f <- factor(vec)
summary(vec.f)
```
So donkey is coded as 1, giraffe as 2 and liger as 3. Coding is alphabetical.
```{r factor2, echo=T}
as.numeric(vec.f)
```

---
name: factors2

## Factors
You can also control the coding/mapping:
```{r factor.coding, echo=T}
vec <- c('giraffe', 'donkey', 'liger', 
         'liger', 'giraffe', 'liger')
vec.f <- factor(vec, levels=c('donkey', 'giraffe', 
                              'liger'), 
                labels=c('zonkey','Sophie','tigon'))
summary(vec.f)
```
A bit confusing, factors...

---
name: ordered_fac

## Ordered
To work with ordinal scale (ordered) variables, one can also use factors:
```{r ordinal, echo=T}
vec <- c('tiny', 'small', 'medium', 'large')
factor(vec) # rearranged alphabetically
factor(vec, ordered=T) # order as provided
```

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# We will talk about matrices in the next lecture!

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```



<!--chapter:end:slide_r_elements_2.Rmd-->

---
title: "Matrices, Lists, Dataframes, S3 and S4 Objects."
subtitle: "Elements of the R language"
author: "Marcin Kierczak"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

---
name: contents

# Contents of the lecture

- variables and their types
- operators
- vectors
- numbers as vectors
- strings as vectors
- **matrices**
- **lists**
- **data frames**
- **objects**
- repeating actions: iteration and recursion
- decision taking: control structures
- functions in general
- variable scope
- core functions

---
name: matrices

# Matrices

A **matrix** is a 2-dimensional data structure, like vector, it consists of elements of the same type. A matrix has *rows* and *columns*.  

Say, we want to construct this matrix in R:
$$\mathbf{X} = \left[\begin{array}
{rrr}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{array}\right]$$
```{r matrix, echo=T}
X <- matrix(1:9, # a sequence of numbers to fill in
       nrow=3, # three rows (alt. ncol=3)
       byrow=T) # populate matrix by row
X
```

---
name: matrices_indexing

# Matrices &mdash; indexing

Elements of a matrix are retrieved using the '[]' notation, like we have seen for vectors. Here, we have to specify 2 dimensions -- the row and the column:

```{r matrix.ind, echo=T}
X[1,2] # Retrieve element from the 1st row, 2nd column
X[3,] # Retrieve the entire 3rd row
X[,2] # Retrieve the 2nd column
```

---
name: matrices_indexing_2

# Matrices &mdash; indexing cted.

```{r matrix.ind2, echo=T}
X[c(1,3),] # Retrieve rows 1 and 3
X[c(1,3),c(3,1)]
```

---
name: matrices_dim

# Matrices &mdash; dimensions

To check the dimensions of a matrix, use dim():
```{r matrix.dim, echo=T}
X
dim(X) # 3 rows and 3 columns
```

Nobody knows why dim() does not work on vectors... use length() instead.

---
name: matrices_oper_1

# Matrices &mdash; operations

Usually the functions that work for a vector also work for matrices.
To order a matrix with respect to, say, 2nd column:
```{r matrix.oper2, echo=T}
X <- matrix(sample(1:9,size = 9), nrow = 3)
ord <- order(X[,2])
X[ord,]
```

---
name: matrices_t

# Matrices &mdash; transposition

To **transpose** a matrix use t():

```{r matrix.t, echo=T}
X
t(X)
```

Nobody knows why dim() does not work on vectors... use length() instead.

---
name: matrices_oper_2

# Matrices &mdash; operations 2

To get the diagonal, of the matrix:
```{r matrix.diag, echo=T}
X
diag(X) # get values on the diagonal
```

---
name: matrices_tri

# Matrices &mdash; operations, triangles

To get the upper or the lower triangle use **upper.tri()** and **lower.tri()** respectively:

```{r matrix.tri, echo=T}
X # print X
upper.tri(X) # which elements form the upper triangle
X[upper.tri(X)] <- 0 # set them to 0
X # print the new matrix
```

---
name: matrices_multi

# Matrices &mdash; multiplication

Different types of matrix multiplication exist:
```{r matrix.multi, echo=T}
A <- matrix(1:4, nrow = 2, byrow=T)
B <- matrix(5:8, nrow = 2, byrow=T)
A * B # Hadamard product
A %*% B # Matrix multiplication
# A %x% B # Kronecker product
# A %o% B # Outer product (tensor product)
```

---
name: matrices_outer

# Matrices &mdash; outer

Outer product can be useful for generating names
```{r matrix.outer1, echo=T}
outer(letters[1:4], LETTERS[1:4], paste, sep="-")
```

---
name: matrices_expand_grid

# Expand grid

But **expand.grid()** is more convenient when you want, e.g. generate combinations of variable values:
```{r matrix.expand.grid, echo=T}
expand.grid(height = seq(120, 121),
            weight = c('1-50', '51+'),
            sex = c("Male","Female"))
```

---
name: matrices_apply

# Matrices &mdash; apply

Function **apply** is a very useful function that applies a given function to either each value of the matrix or in a column/row-wise manner. Say, we want to have mean of values by column:

```{r matrix.apply, echo=T}
X
apply(X, MARGIN=2, mean) # MARGIN=1 would do it for rows
```

---
name: matrices_apply_2

# Matrices &mdash; apply cted.

And now we will use *apply()* to replace each element it a matrix with its deviation from the mean squared:

```{r matrix.apply2, echo=T}
X
my.mean <- mean(X)
apply(X, MARGIN=c(1,2),
      function(x, my.mean) (x - my.mean)^2,
      my.mean)
```

---
name: matrices_colSums

# Matrices &mdash; useful fns.

While *apply()* is handy, it is a bit slow and for the most common statistics, there are special functions col/row Sums/Means:

```{r matrix.colSums, echo=T}
X
colSums(X)
```
These functions are faster!

---
name: matrices_add_row_col

# Matrices &mdash; adding rows/columns

One may wish to add a row or a column to an already existing matrix or to make a matrix out of two or more vectors of equal length:

```{r matrix.binding, echo=T}
x <- c(1,1,1)
y <- c(2,2,2)
cbind(x,y)
rbind(x,y)
```

---
name: matrices_arrays

# Matrices &mdash; more dimensions

```{r matrix.multidim, echo=T}
dim(Titanic)
```

--

```{r matrix.Titanic.plot, echo=F, message=F, fig.width = 6, fig.height = 3.5, dpi=120}
library(vcd)
mosaic(Titanic, gp_labels=gpar(fontsize=7))
```

---
name: lists_1

# Lists  &mdash; collections of various data types

A list is a collection of elements that can be of various data types:

```{r lists, echo=T}
name <- c('R2D2', 'C3PO', 'BB8')
weight <- c(21, 54, 17)
data <- list(name=name, weight)
data
data$name
data[[1]]
```

---
name: lists_2

# Lists &mdash; collections of various data types

Elements of a list can also be different data structures:

```{r lists2, echo=T}
weight <- matrix(sample(1:9, size = 9), nrow=3)
data <- list(name, weight)
data
data[[2]][3]
```

---
name: data_frames_1

# Data frames  

A **data frame** or a **data table** is a data structure very handy to use. In this structure elements of every column have the same type, but different columns can have different types. Technically, a data frame is a list of vectors...
```{r data.frame1, echo=T}
df <- data.frame(c(1:5),
                 LETTERS[1:5],
                 sample(c(TRUE, FALSE), size = 5,
                        replace=T))
df
```

---
name: data_frames_2

# Data frames &mdash; cted.

As you have seen, columns of a data frame are named after the call that created them. Not always the best option...
```{r data.frame2, echo=T}
df <- data.frame(no=c(1:5),
                 letter=c('a','b','c','d','e'),
                 isBrown=sample(c(TRUE, FALSE),
                        size = 5,
                        replace=T))
df
```

---
name: data_frames_acccessing

# Data frames &mdash; accessing values

As you have seen, columns of a data frame are named after the call that created them. Not always the best option...

```{r data.frame.access, echo=T}
df[1,]  # get the first row
df[,2]  # the first column
df[2:3, 'isBrown'] # get rows 2-3 from the isBrown column
df$letter[1:2] # get the first 2 letters
```

---
name: data_frames_factors_1

# Data frames &mdash; factors

An interesting observation:

```{r data.frame.factor, echo=T}
df$letter
df$letter <- as.character(df$letter)
df$letter
```
---
name: data_frames_factors_2

# Data frames &mdash; factors cted.

To treat characters as characters at data frame creation time, one can use the **stringsAsFactors** option set to TRUE:

```{r data.frame.factor2, echo=T}
df <- data.frame(no=c(1:5),
                 letter=c("a","b","c","d","e"),
                 isBrown=sample(c(TRUE, FALSE),
                        size = 5,
                        replace=T),
                 stringsAsFactors = TRUE)
df$letter
```
Well, as you see, it did not work as expected...

---
name: data_frames_names

# Data frames &mdash; names

To get or change row/column names:

```{r data.frame.names, echo=T}
colnames(df) # get column names
rownames(df) # get row names
rownames(df) <- letters[1:5]
rownames(df)
df['b', ]
```

---
name: data_frames_merging

# Data frames &mdash; merging

A very useful feature of R is merging two data frames on certain key using  **merge**:

```{r data.frame.merge, echo=T}
df1 <- data.frame(no=c(1:5),
                 letter=c("a","b","c","d","e"))
df2 <- data.frame(no=c(1:5),
                 letter=c("A","B","C","D","E"))
merge(df1, df2, by='no')
```

---
name: objects_type_class

# Objects &mdash; type vs. class

An object of class **factor** is internally represented by numbers:

```{r obj.type.class, echo=T}
size <- factor('small')
class(size) # Class 'factor'
mode(size) # Is represented by 'numeric'
typeof(size) # Of integer type
```

---
name: objects_str

# Objects &mdash; structure

Many functions return **objects**. We can easily examine their **structure**:

```{r obj.str, echo=T, fig.height=3.7, fig.width=3}
his <- hist(1:5, plot=F)
str(his)
object.size(hist) # How much memory the object consumes
```

---
name: objects_fix

# Objects &mdash; fix

We can easily modify values of object's **attributes**:

```{r obj.fix, echo=T}
attributes(his)
attr(his, "names")
#fix(his) # Opens an object editor
```

---
name: objects_lists_as_S3

# Lists as S3 classes

A list that has been named, becomes an S3 class:
```{r obj.S3.list, echo=T}
my.list <- list(numbers = c(1:5),
                letters = letters[1:5])
class(my.list)
class(my.list) <- 'my.list.class'
class(my.list) # Now the list is of S3 class
```

However, that was it. We cannot enforce that *numbers* will contain numeric values and that *letters* will contain only characters. S3 is a very primitive class.

---
name: objects_S3

# S3 classes

For an S3 class we can define a *generic function* applicable to all objects of this class.
```{r obj.S3, echo=T}
print.my.list.class <- function(x) {
  cat('Numbers:', x$numbers, '\n')
  cat('Letters:', x$letters)
}
print(my.list)
```

But here, we have no error-proofing. If the object will lack *numbers*, the function will still be called:

```{r obj.S3.error, echo=T}
class(his) <- 'my.list.class' # alter class
print(his) # Gibberish but no error...
```

---
name: objects_generics

# S3 classes &mdash; still useful?

Well, S3 class mechanism is still in use, esp. when writing **generic** functions, most common examples being *print* and *plot*. For example, if you plot an object of a Manhattan.plot class, you write *plot(gwas.result)* but the true call is: *plot.manhattan(gwas.result)*. This makes life easier as it requires less writing, but it is up to the function developers to make sure everything works!

---
name: objects_S4

# S4 class mechanism

S4 classes are more advanced as you actually define the structure of the data within the object of your particular class:
```{r S4, echo=T}
setClass('gene',
         representation(name='character',
                        coords='numeric')
         )
my.gene <- new('gene', name='ANK3',
               coords=c(1.4e6, 1.412e6))
```

---
name: objects_S4_slots

# S4 class &mdash; slots

The variables within an S4 class are stored in the so-called **slots**. In the above example, we have 2 such slots: *name* and *coords*. Here is how to access them:

```{r S4.slots, echo=T}
my.gene@name # access using @ operator
my.gene@coords[2] # access the 2nd element in slot coords
```

---
name: objects_S4_methods

# S4 class &mdash; methods

The power of classes lies in the fact that they define both the data types in particular slots and operations (functions) we can perform on them. Let us define a *generic print function* for an S4 class:

```{r S4.methods, echo=T}
setMethod('print', 'gene',
          function(x) {
              cat('GENE: ', x@name, ' --> ')
              cat('[', x@coords, ']')
          })
print(my.gene) # and we use the newly defined print
```

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# See you at the next lecture!

```{r, echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_elements_3.Rmd-->

---
title: "Replication, Control Structures & Functions"
subtitle: "Elements of the R language"
author: "Marcin Kierczak and Nima Rafati"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

---
name: contents

# Contents of the lecture

- variables and their types
- operators
- vectors
- numbers as vectors
- strings as vectors
- matrices
- lists
- data frames
- objects
- **repeating actions: iteration and recursion**
- **decision taking: control structures**
- **functions in general**
- **variable scope**
- **base functions**

---
name: repeating_actions_1

# Repeating actions

Somtimes you want to repeat certain action several times.  

There are few alternatives in R, for example:  
- `for` loop 
- `while` loop   

---
name: for_loop_0

# Repeating actions &mdash; for loop

One way to repeat an action is to use the **for-loop**

```{r for.loop.general, eval=FALSE, echo=TRUE}
for (var in seq) {
  expr
}
```

---
name: for_loop_1
# Repeating actions &mdash; for loop

Example. 

```{r for.loop, echo=T}
for (i in 1:5) {
  cat(paste('Performing operation no.', i), '\n')
}
```

--

A slight modification of the above example will skip odd indices.

```{r for.loop2, echo=T}
for (i in c(2,4,6,8,10)) {
  cat(paste('Performing operation no.', i), '\n')
}
```

---
name: for_loop_counter

# Repeating actions &mdash; for loop with a counter

Sometimes, we also want an external counter:

```{r for.loop.cnt, echo=T}
cnt <- 1
for (i in c(2,4,6,8,10)) {
  cat(paste('Performing operation no.', cnt,
            'on element', i), '\n')
  cnt <- cnt + 1
}
```

---
name: for_loop_example

# Repeating actions &mdash; for loop, an example

Say, we want to add 1 to every element of a vector:

```{r for.loop.ex1, echo=T}
vec <- c(1:5)
vec
for (i in vec) {
  vec[i] <- vec[i] + 1
}
vec
```

--

The above can be achieved in R by means of **vectorization**.  
**Vectorization** is an element-wise operation where you perform task/operation on entire vectors/matrix/data.frames.

```{r for.loop.avoid, echo=T}
vec <- c(1:5)
vec + 1  
```

---
name: vectorization_benchmark

# Repeating actions &mdash; vectorization

Let us compare the time of execution of the vectorized version (vector with 10,000 elements):

```{r for.loop.avoid.timing, echo=T}
vec <- c(1:1e6)
ptm <- proc.time()
vec <- vec + 1
proc.time() - ptm # vectorized
```

--

to the loop version:

```{r for.loop.avoid.timing2, echo=T}
vec <- c(1:1e6)
ptm <- proc.time()
for (i in vec) {
  vec[i] <- vec[i] + 1
}
proc.time() - ptm # for-loop
```

---
name: while_loop

# Repeating actions &mdash; the while loop

There is also another type of loop in R, the **while loop** which is executed as long as some condition is true.
```{r loop.while, echo=T}
x <- 1
while (x < 5) {
  cat(x, " ... ")
  x <- x + 1
}
```

---
name: recursion

<!-- # Recursion

When we explicitely repeat an action using a loop, we talk about **iteration**. We can also repeat actions by means of **recursion**, i.e. when a function calls itself. Let us implement a factorial $!$:

```{r rec.fact, echo=F}
factorial.rec <- function(x) {
  if (x == 0 || x == 1)
    return(1)
  else
    return(x * factorial.rec(x - 1)) # Recursive call!
}
factorial.rec(5)
```


# Recursion = iteration?
Yes, every iteration can be converted to recursion (Church-Turing conjecture) and vice-versa. It is not always obvious, but theoretically it is doable. Let's see how to implement *factorial* in iterative manner:
```{r rec.fact.iter, echo=T}
factorial.iter <- function(x) {
  if (x == 0 || x == 1)
    return(1)
  else {
    tmp <- 1
    for (i in 2:x) {
      tmp <- tmp * i
    }
    return(tmp)  
  }
}
factorial.iter(5)
```

# Recursion == iteration, really?
More writing for the iterative version, right? What about the time efficiency?  
The recursive version:
```{r rec.fact.timing, echo=F}
ptm <- proc.time()
factorial.rec(20)
proc.time() - ptm
```
And the iterative one:
```{r iter.fact.timing, echo=F}
ptm <- proc.time()
factorial.iter(20)
proc.time() - ptm
```
-->

---
name: loops_avoid_growing

# Loops &mdash; avoid growing data

Avoid changing dimensions of an object inside the loop:

```{r avoid.growing, echo=T}
v <- c() # Initialize
for (i in 1:100) {
  v <- c(v, i)
}
```

--

It is much better to do it like this:

```{r avoid.growing2, echo=T}
v <- rep(NA, 100) # Initialize with length
for (i in 1:100) {
  v[i] <- i
}
```

--

Always try to know the size of the object you are going to create!

---
name: if_clause

# Decisions, an if-clause

Often, one has to take a different course of action depending on a flow of the algorithm. Let's print only odd numbers $[1, 10]$:

```{r if, echo=T}
v <- 1:10
for (i in v) {
  if (i %% 2 != 0) { # if clause
    cat(i, ' ')
  }
}
```

---
name:if_else

# Decisions &mdash; if-else

If we want to print 'o' for an odd number and 'e' for an even, we could write either of:

.pull-left-50[
```{r ifelse1, echo=T}
v <- 1:10
for (i in v) {
  if (i %% 2 != 0) { # if clause
    cat('o ')
  }
  if (i %% 2 == 0) { # another if-clause
    cat('e ')
  }
}
```
]

--

.pull-right-50[
```{r ifelse2, echo=T}
v <- 1:10
for (i in v) {
  if (i %% 2 != 0) { # if clause
    cat('o ')
  } else { # another if-clause
    cat('e ')
  }
}
```
]

--

.pull-left-50[
```{r ifelse3, echo=T}
v <- 1:10
for (i in v) {
  tmp <- 'e ' # set default to even
  if (i %% 2 != 0) { # if clause
    tmp <- 'o ' # change default for odd numbers
  }
  cat(tmp)
}
```
]

--

Each of these three ways are equally good and are mainly the matter of style...

---
name: elif

# Decision taking &mdash; more alternatives

So far, so good, but we were only dealing with 3 alternatives. Let's say that we want to print '?' for zero, 'e' for even and 'o' for an odd number:

```{r if.elseif, echo=T}
v <- c(0:10)
for (i in v) {
  if (i == 0) {
    cat('? ')
  } else if (i %% 2 != 0) { # if clause
    cat('o ')
  } else { # another if-clause
    cat('e ')
  }
}
```
Congratulations! You have just learned the **if-elseif-else** clause.

---
name: switch

# Switch

If-else clauses operate on logical values. What if we want to take decisions based on non-logical values? Well, if-else will still work by evaluating a number of comparisons, but we can also use **switch**:

```{r switch, echo=T}
switch.demo <- function(x) {
  switch(class(x),
         logical = cat('logical\n'),
         numeric = cat('Numeric\n'),
         factor = cat('Factor\n'),
         cat('Undefined\n')
         )
}
switch.demo(x=TRUE)
switch.demo(x=15)
switch.demo(x=factor('a'))
switch.demo(data.frame())
```

---
name: fns

# Functions

Often, it is really handy to re-use some code we have written or to pack together the code that is doing some task. Functions are a really good way to do this in R:

```{r functions1, echo=T,error=T}
add.one <- function(arg1) {
  arg1 <- arg1 + 1
  return(arg1)
}
add.one(1)
add.one()
```

---
name:anatomy_of_a_fn

# Anatomy of a function

A function consists of: *formal arguments*, *function body* and *environment*:

```{r fns.formalsbodyenv, echo=T}
formals(add.one)
body(add.one)
environment(add.one)
environment(sd)
```

---
name: fns_defaults

# Functions &mdash; default values

Sometimes, it is good to use default values for some arguments:

```{r functions2, echo=T, error=T}
add.a.num <- function(arg, num=1) {
  arg <- arg + num
  return(arg)
}
add.a.num(1, 5)
add.a.num(1) # skip the num argument
add.a.num(num=1) # skip the first argument
```

---
name:fns_args

# Functions &mdash; order of arguments

```{r functions3, echo=T}
args.demo <- function(x, y, arg3) {
  print(paste('x =', x, 'y =', y, 'arg3 =', arg3))
}
args.demo(1,2,3)
args.demo(x=1, y=2, arg3=3)
args.demo(x=1, 2, 3)
args.demo(arg3=3, x=1, y=2)
```

<!--  
--

```{r functions4, echo=F, error=F}
args.demo2 <- function(x, arg2, arg3) {
  print(paste('x =', x, 'arg2 =', arg2, 'arg3 =', arg3))
}
#args.demo2(x=1, y=2, ar=3)
```
-->

---
name: variable_scope

# Functions &mdash; variable scope

.pull-left-50[
Functions 'see' not only what has been passed to them as arguments:
```{r fns.varscope, echo=T}
x <- 7
y <- 3
xyplus <- function(x) {
  x <- x + y
  return(x)
}
xyplus(x)
x
```
]

--

.pull-right-50[
Everything outside the function is called **global environment**. There is a special operator `<<-` for working on global environment:

```{r fns.varscope.glob, echo=T}
x <- 1
xplus <- function(x) {
  x <<- x + 1
}
xplus(x)
x
xplus(x)
x
```
]

---
name: fns_ellipsis

# Functions &mdash; the `...` argument

There is a special argument **...** (ellipsis) which allows you to give any number of arguments or pass arguments downstream:

```{r fns.3dots, echo=T, fig.height = 3, fig.width = 6}
# Any number of arguments
my.plot <- function(x, y, ...) { # Passing downstream
  plot(x, y, las=1, cex.axis=.8, ...)
}

{par(mfrow=c(1,2),mar=c(4,4,1,1))
my.plot(1,1)
my.plot(1, 1, col='red', pch=19)}
```

- A function enclosing a function is a **wrapper function**

---
name: ellipsis_trick

# Functions &mdash; the ellipsis argument trick

What if the authors of, e.g. plot.something wrapper forgot about the `...`?

```{r fns.3dots.trick, echo=T, fig.height = 5, fig.width = 5}
my.plot <- function(x, y) { # Passing downstrem
  plot(x, y, las=1, cex.axis=.8, ...)
}
formals(my.plot) <- c(formals(my.plot), alist(... = ))
my.plot(1, 1, col='red', pch=19)
```

---
<!--  
name: lazy_eval

# R is lazy!

In R, arguments are evaluated as late as possible, i.e. when they are needed. This is **lazy evaluation**:

```{r lazy.eval, echo=F, eval = T}
h <- function(a = 1, b = d) {
  d <- (a + 1) ^ 2
  c(a, b)
}
#h()
```

> The above won't be possible in, e.g. C where values of both arguments have to be known before calling a function **eager evaluation**.  
-->
---

name: everything_is_a_fn

# In R everything is a function

Because in R everything is a function

```{r fns.everything_1, echo=F}
`+`
```

--

we can re-define things like this:

--

```{r fns.everything_2, echo=T}
`+` <- function(e1, e2) { e1 - e2 }
2 + 2
```

--

and, finally, clean up the mess...

--

```{r fns.everything_3, echo=T}
rm("+")
2 + 2
```

---
name: infix_fns

# Infix notation

Operators like `+`, `-` or `*` are using the so-called **infix** functions, where the function name is between arguments. We can define our own:

```{r infix, echo=T}
`%p%` <- function(x, y) {
  paste(x,y)
}
'a' %p% 'b'
```

---
name: base_fns

# Base functions

When we start R, the following packages are pre-loaded automatically:

```{r preloaded.packages, echo=T}
# .libPaths() # get library location
# library()   # see all packages installed
search()    # see packages currently loaded
```

Check what basic functions are offered by packages: *base*, *utils* and we will soon work with package *graphics*. If you want to see what statistical functions are in your arsenal, check out package *stats*.

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# See you at the next lecture!

```{r, echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_elements_4.Rmd-->

---
title: "Working in the R environment"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, width=60)
```

```{r,include=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
library(mkteachr)
```

---
name: working_with_r

# Working with R

There are several ways to work with/in R:

- from a command line,
- in batch mode,
- from a native GUI,
- using external editor, e.g. RStudio.

During this course, we will be focusing on working with [RStudio](https://www.rstudio.com) and also in *batch mode*.

---
name: cline_working

# Working from command line

1. Open Terminal.
2. Type `R`.
3. Type R commands...
4. Type `q()` to quit R.

- Arrows let you browse throughout the history.
- .kbd[TAB] attempts to autocomplete the command you have just started typing.

---
name: batch_mode

# The batch mode

If you are working on a computational cluster, such as the Uppmax, it is very likely you would like to run large jobs that one has to enqueue. This makes interactive work from the console virtually impossible. The solution is to run R code from a file, using the so-called **batch mode**:

1. Create a file with your code and give it extension **.R**.
2. In the console (or in the queue script) write:  

`R --vanilla < mycode.R` [two minus signs in front of *vanilla*].

Should you like to log the output add either:

- `R --vanilla < mycode.R > output.log` or like this
- `R --vanilla < mycode.R | tee output.log`  

---
name: help

# Getting help

```{r help,echo=TRUE,eval=FALSE}
help(t.test) # function level
?t.test # same as above
??t.test # extensive search
vignette("GenABEL") # package level demo(graphics)
example(barplot) # run help examples for barplot
demo() # see all currently available demos
demo('graphics') # run demo for 'graphics'
```

[Stackoverflow](http://stackoverflow.com) is a great resource.

---
name: work_with_packages

# Working with packages

Packages are organised in repositories. The three main repositories are:

* [CRAN](https://cran.r-project.org)
* [R-Forge](http://r-forge.r-project.org)
* [Bioconductor](http://www.bioconductor.org)

We also have [GitHub](https://github.com).

--
# Working with packages -- CRAN example.

```{r,out.width="400pt",fig.align='center',echo=FALSE}
knitr::include_graphics("data/slide_r_environment/cran-package.png")
```

---
name: pkg_cran_inst

# Working with packages -- installation

Only a few packages are pre-installed:

```{r pkg.err.ex,eval=TRUE,error=TRUE}
library(XLConnect)
```

In order to install a package from command line, use:

```{r pkg.inst,eval=FALSE}
install.packages("GenABEL",dependencies=TRUE)
```

---
name: work_pkg_details

# Working with packages -- details

It may happen that you want to also specify the repository, e.g. because it is geographically closer to you or because your default mirror is down:

```{r pkg.inst.repo,eval=FALSE}
install.packages('GenABEL',dependencies=TRUE,repos="http://cran.se.r-project.org")
```

But, sometimes, this does not work either because the package is not available for your platform. In such case, you need to *compile* it from its *source code*.

---
name: work_pkg_details2

# Working with packages -- details cted.
```{r,out.width="400pt",fig.align='center',echo=FALSE}
knitr::include_graphics("data/slide_r_environment/cran-package.png")
```

---
name: source_pkg_inst

# Working with packages -- installing from source.

- Make sure you have appropriate tools installed, e.g. XCode or build-essentials.
- Download the source file, in our example *GenABEL_1.8-0.tar.gz*.
- Install it:

```{r pkg.inst.src,eval=FALSE}
install.packages("path/to/GenABEL_1.8-0.tar.gz",
                 repos=NULL,
                 type='source',
                 dependencies=TRUE)
```

- Load it:

```{r pkg.load,eval=FALSE}
library('GenABEL') # always forces reloading
require('GenABEL') # load only if not already loaded
```

- Enjoy!

---
name: pkg_github

# Packages -- GitHub

Nowadays, more and more developers contribute their packages via GitHub. The easiest way to install packages from the GitHub is via the *devtools* package:

- Install the *devtools* package.
- Load it.
- Install.
- Enjoy!

```{r pkg.inst.devtools.github,eval=FALSE}
install.packages('devtools',dependencies=TRUE)
library('devtools')
install_github('talgalili/installr')
```

---
name: pkg_bioconductor

# Packages -- Bioconductor

```{r,out.width="200pt",fig.align='center',echo=FALSE}
knitr::include_graphics("data/slide_r_environment/logo_bioconductor.png")
```

First install Bioconductor Manager:

```{r inst.biocond,eval=FALSE}
if (!requireNamespace("BiocManager",quietly = TRUE))
    install.packages("BiocManager")
```

---
name: pkg_bioconductor2

# Packages -- Bioconductor cted.

Now, you can install particular packages from Bioconductor:

```{r biocond.inst.pkg,eval=FALSE}
BiocManager::install("GenomicRanges")
```

For more info, visit [Bioconductor website](http://www.bioconductor.org/install/).

---
# One package to rule them all -- the magic of `renv`

- first time do `renv::activate()` and `renv::init()`
- while working: `renv::hydrate()` and `renv::snapshot()`

Now, send `renv.lock` to your friend to share the environment and she can:

- restore the environment `renv::restore()`

**Pure magic!**

---
name: rstudio

# RStudio -- a live demonstration

![RStudio screenshot](data/slide_r_environment/RStudio.png)

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# See you at the next lecture!

```{r, echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_environment.Rmd-->

---
title: "Introduction to R"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
library(mkteachr)
```

---
name: content
class: spaced

# Contents

* [About R](#about)
* [Timeline](#timeline)
* [Ideas behind R](#ideas)
* [Pros and cons of R](#pros_and_cons)
* [Ecosystem of packages](#num_packages)

---
name: about

# Briefly about R

.pull-left-50[

# R is ...

* a programming language
* a programming platform (= environment + interpreter)
* a software project driven by the core team and the community
* a very powerful tool for statistical computing
* a very powerful computational tool in general
* a catalyst between an idea and its realization  

]

--

.pull-right-50[

# R is not ...

* a tool to replace a statistician
* the very best programming language
* the most elegant programming solution
* the most efficient programming language  

]

--

.pull-left-70[

# Yet ...

* it is very elegant
* it becomes more and more feature-rich

]

.pull-right-30[
![](data/common/r.png)
]

---
name: timeline

# Timeline

--

.pull-left-50[

![](data/slide_intro/Ihaka_and_Gentleman.jpg)

* ca. 1992 &mdash; conceived by [Robert Gentleman](https://bit.ly/35kn99L) and [Ross Ihaka](https://en.wikipedia.org/wiki/Ross_Ihaka) (R&R) at the University of Auckland, NZ as a tool for **teaching statistics**

* 1994 &mdash; initial version
* 2000 &mdash; stable version

]

--

.pull-right-50[

![](data/slide_intro/jjallaire_siliconangle_com.jpg)

* 2011 &mdash; [RStudio](https://en.wikipedia.org/wiki/RStudio), first release by J.J. Allaire

![](data/slide_intro/hadley-wickham.jpg)

* ca. 2017 &mdash; Tidyverse by [Hadley Wickham](https://en.wikipedia.org/wiki/Hadley_Wickham)
]

---
name: ideas

# Ideas behind R

* open-source solution &mdash; fast development

--

* based on the [S language](https://en.wikipedia.org/wiki/S_%28programming_language%29) created at the Bell Labs by [John Mc Kinley Chambers](https://bit.ly/2RhDqUx) to

> *turn ideas into software, quickly and faithfully*

--

* [lexical scope](https://en.wikipedia.org/wiki/Scope_%28computer_science%29%23Lexical_scoping) inspired by [Lisp](https://en.wikipedia.org/wiki/Lisp) syntax

--

* since 1997 developed by the R Development Core Team (ca. 20 experts, with Chambers onboard; 6 are active)

--

* overviewed by [The R Foundation for Statistical Computing](https://www.r-project.org/foundation/)

---
name: packages

# Packages

.pull-right-50[
```{r, out.width="250pt", fig.align='center', echo=FALSE}
knitr::include_graphics("data/slide_intro/packages.jpg")
```
]

--

* developed by the community

--

* cover several very diverse areas of science/life

--

* uniformely structured and documented

--

* organised in repositiries:
    + [CRAN](https://cran.r-project.org)
    + [R-Forge](https://r-forge.r-project.org)
    + [Bioconductor](http://www.bioconductor.org)
    + [GitHub](https://github.com)

---
name: pros_and_cons
class: spaced

# Pros and cons

<i class='fa fa-minus-square'></i> steep learning curve  

--
<i class='fa fa-plus-square'></i> uniform, clear and clean system of documentation and help  

--
<i class='fa fa-minus-square'></i> difficulties due to a limited object-oriented programming capabilities,  
e.g. an agent-based simulation is a challenge  

--
<i class='fa fa-plus-square'></i> good interconnectivity with compiled languages like Java or C    

--
<i class='fa fa-minus-square'></i> cannot order a pizza for you (?)  

--
<i class='fa fa-plus-square'></i> a very powerful ecosystem of packages  

--
<i class='fa fa-plus-square'></i> free and open source, GNU GPL and GNU GPL 2.0  

--
<i class='fa fa-plus-square'></i> easy to generate high quality graphics  

---
name: num_packages

# Ecosystem of R packages

<br>

```{r num_pkgs, echo=FALSE, fig.align='center', fig.height=7, fig.width=9, cache=TRUE, message=FALSE}
data <- mkteachr::update_repos_data()
gg <- mkteachr::plot_repos_data(data)
gg
```

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# Thank you! Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
#rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_intro.Rmd-->

---
title: "Introduction To Programming in R (1)"
subtitle: "R Foundations for Life Scientists"
author: "Marcin Kierczak"
keywords: bioinformatics, course, scilifelab, nbis, R
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---
exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ------------ Only edit title, subtitle & author above this ------------ -->

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need
#library(dplyr)
#library(tidyr)
#library(stringr)
#library(ggplot2)
```

---
name: programming_language

# Computer program

--

 * flow of data

--

 * from one function to another

--

 * each function does something to the data  

--

# How?

--
> A **programming language** is a formal computer language or constructed language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs to control the behavior of a machine or to express algorithms.  
.small[[Wikipedia](https://en.wikipedia.org/wiki/Programming_language)]

--

# Three things to think about

 * what *types* of data can I process?

--

 * how do I *write* what I want?

--

 * when does it *mean* anything?


---

# Three components of a language

--

 * what *types* of data can I process &mdash; *type system*

--

  * int &mdash; 1 2 5 9
  * double &mdash; 1.23 -5.74
  * char &mdash; a b test 7 9

--

 * how do I *write* what I want &mdash; *syntax* defined by a language *grammar*

  `2 * 1 + 1` vs. `(+ (* 2 1) 1)`

--

 * when does it *mean* anything &mdash; *semantics*

--

  * *Colorful yellow train sleeps on a crazy wave.* &mdash; has no generally accepted meaning
  * *There is $500 on his empty bank acount.* &mdash; internal contradiction

---
name: topic2

# Where to start?


*Divide et impera* &mdash; divide and rule.

**Top-down approach:** define the big problem and split it into smaller ones. Assume you have solution to the small problems and continue &mdash; push the responsibility down.
Wishful thinking!

<!-- --------------------- Do not edit this and below --------------------- -->

---
name: end_slide
class: end-slide, middle
count: false

# Thank you. Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

```{r,include=FALSE,eval=FALSE}
# manually run this to render this document to HTML
rmarkdown::render("presentation_demo.Rmd")
# manually run this to convert HTML to PDF
#pagedown::chrome_print("presentation_demo.html",output="presentation_demo.pdf")
```

<!--chapter:end:slide_r_programming_1.Rmd-->

---
title: "R Package Anatomy"
subtitle: "R Foundations for Life Scientists"
author: "Sebastian DiLorenzo"
keywords: r, r programming, markdown, tidyverse
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need

#library(tidyverse)
#library(ggplot2) # static graphics
```

---

# Overview

.pull-left-70[
* [What is an R package?](#rpkg)
* [Possible package states](#pkg-states)
<!-- * [Repositories](#)Include? -->
* Package structure:
    + [Code | `r/`](#r)
    + [Metadata | `DESCRIPTION`](#desc)
    + [Documentation | `man/`](#man)
    + [Vignettes](#vig)
    + [Import & Export | `NAMESPACE`](#namespace)
    + [Data | `data/`](#data)
    + [Compiled code | `src/`](#src)
<!--    + [Installed files | `inst/`](#) Include? -->
<!-- * [Testing](#)  Include? -->
* [git, Github, Rstudio and you!](#git)
* [CRAN and `R CMD check`](#cran)
<!-- * [Package website | `pkgdown`](#)  Include? -->
]

.pull-right-30[
<img src="data/slide_rpackage/rpkg_book.png">
.vsmall[http://r-pkgs.had.co.nz/]
]

???
An overview of the topics I will discuss during the lecture.
"What is an R package" is what should come to mind when thinking an R package.
In "Possible package states" I will talk about the the different forms we can find R packages in, such as development and installed.
In package structure I will walk through each of the folders usually included in an R package.
"git, github, Rstudio and you" is about why git, github and rstudio are good working environments for package development.
And in "Cran and "R CMD check"" I will talk about tools to check your package and the requirements and pros/cons of submitting it CRAN.

---
name: rpkg

# What is an R package?

.pull-left-50[
<img src="data/slide_rpackage/tree_rpkg_mini.png", style="width:60%">
]

.pull-right-50[
* A strict and connected folder and file structure
]

???

You can think of an R package under development as a folder and file structure with some predetermined names and connectivity. So really, a package is more about knowing how to organise code and other files than being a good R programmer. There are also some differences in how you write code that is intended to be used for a package than a script for analysis for example. But I will get back to this.  The minimal required package has a DESCRIPTION, a NAMESPACE an R folder for code and here we also see a R project file created by Rstudio which is not required.

---

# What is an R package?

.pull-left-50[
<img src="data/slide_rpackage/tree_rpkg_mini.png", style="width:60%">
<img src="data/slide_rpackage/tree_rpkg.png", style="width:60%">
]

.pull-right-50[
* A strict and connected folder and file structure
]

???

There are many additional components you can add to the package, more than are shown here, I will go through the major parts of these in this lecture. So what are R packages for?

---

# What is an R package?

.pull-left-50[
<img src="data/slide_rpackage/tree_rpkg_mini.png", style="width:60%">
<img src="data/slide_rpackage/tree_rpkg.png", style="width:60%">
]

.pull-right-50[
* A strict and connected folder and file structure
* Sharing code
* Improved quality and rigor
    + Documentation
    + Tests
    + Examples
* Efficiency
* Improvability
]

???

R packages are for sharing code in a way where others can use it. It also forces the author to include elements which can improve the quality of the code, such as documentation, examples and tests. This is a benefit no matter if the package is intended for other users or not. It really helps when coming back to your own code at a later date. Once you get better at writing packages it may even be more time efficient to write a package even if you are not going to share it.

--

.pull-right-50[
* **Reproducibility**
]

???

Finally; At the moment there is much talk about the reproducibility crisis and creating code in this way is definitely in line with good reproducibility.

---
name: pkg-tips

# Package naming

.pull-left-50[
* A name that describes your packages function
    + Letters, numbers and periods
    + Must start with letter
    + Cannot end with period
* Make it googleable
* Check that it doesn't already exist!
    + CRAN
    + github
    + Bioconductor
]

---
name: pkg-states

# Possible package states

There are five states a package can exist in:
* Source
* Bundled
* Binary
* Installed
* In-memory

???

To help understand what's going on with a package it is useful to know the possible states a package can be in.

---

# Source

The development version of your package. The collection of files on your computer.

--

# Bundled

* A compressed, tar.gz, source package with vignettes built
* .Rbuildignore files are excluded
    + Useful for data for example

???

We will get to what vignettes are.

--

# Binary

* A bundle that is built for a certain architecture
* Parsed format, skipping the development tools needed to take the package between source and being interpretable by R

???

Like the bundled package except that if you uncompressed it doesnt look like the source package. This is because it is built for a certain architecture, or operating system.

---

# Installed

* A binary package decompressed into a package library for R
    + The package library is the directory or directories where `library(packagename)` searches
        + `.libPaths()`

--

# In-memory

When you use a package, it is in memory. When developing, a package does not have to be installed to be in memory.
* `packagename::function()`
    + loads packagename

Note:
* `library(packagename)`
    + loads and attaches packagename

???

There is a subtle difference between loading a package into memory to be able to use the functions and also attaching it to the search path so you can use the functions without writing packagename::function(). When you are developing a package it is good to avoid using library and attaching a package because it makes it clearer which package you want the method to come from and having your package attach another package to its search path can mess up your users scripts.

---

# Possible package states

<img src="data/slide_rpackage/installation.png">
.vsmall[http://r-pkgs.had.co.nz/package.html]


???

This image is from Hadleys great introduction to developing packages and I think it illustrates very well how when you run install.packages() from CRAN what is really happening is that it determining what operating system you are on, getting the correct binary version of the package and then, on your device, running R CMD install to put it in your R library. From there you can use the library() command, or not if you are developing, to take it into memory. Whereas if you use type = "source" it will not infer your architecture and grab the bundled source if you will instead. This process will demand that you have the tools on your computer to build the correct binary and install.

---
name: r

# R/

.pull-left-40[
<img src="data/slide_rpackage/tree_rpkg.png", style="width:80%">
]

???

Now we will start to go through the folders and files in a package to see how they interact, what belongs where and what they do.

---

# R/

.pull-left-40[
<img src="data/slide_rpackage/tree_rpkg.png", style="width:80%;opacity:0.5">
<img src="data/slide_rpackage/tree_r.png", style="width:80%">
]

.pull-right-60[
* Code
    + Large functions in their own R files
    + Utility functions, that your package uses, in one R file
* Bad code
    + `library()`, `require()`, `source()`
    + `options()`, `par()`


]

???

The first folder is the R/ folder. This is where your R code lives. You should try to keep it organized with functions that your user will be using grouped in some R files, and your utility functions in their own R file. Utility functions are functions that you dont expect your user to run, rather they are used by your main functions. If a function doesnt fit in a group or is very large, it can have its own R file, but each function should not have their own R file.
You should avoid using functions in your code that modify the environment of your user. For example if you use library() it will attach the package functions of your user, perhaps getting in the way of other functions he was already using elsewhere. It is better to be explicit then and only load a package into memory. If you change options() or par() settings you should revert them before ending the function so your users environment isnt changed.

---
name: desc

# DESCRIPTION

<img src="data/slide_rpackage/DESCRIPTION.png">

???

Now lets look at the DESCRIPTION file. This file handles the metadata of your package. You can change the name of your package in the title here but remember then to change the folder of your package as they should match.

--

.pull-left-30[
* Title
    + 65 characters, no punctuation
* Version
    + The version of the package

* Description
    + One paragraph

<br>
.footnote[.small[.bold[*]:required]]
]

.pull-right-70[
* Authors@R
    + Roles
        + **cre***: Creator or maintainer.
        + **aut***: Author or authors, that have made significant contributions.
        + **ctb**: Contributors, have made smaller contributions.
        + **cph**: Copyright holder. Used if copyright is held by someone other than author, typically company.
]

???

Not all of the fields in DESCRIPTION are important unless you plan to distribute you package to other users.
The title of you package should be a short description, no more than 65 characters. I'll talk more in a second about version number recommendations but for now it is enough to say that it is the version of your package and you decide what version your package is in. The author can be one or many people, with names, emails and roles. Every package must have a creator or maintainer and any number of authors, the rest is optional.

---

# DESCRIPTION

<img src="data/slide_rpackage/DESCRIPTION.png">

.pull-left-50[
* Depends & Imports
    + Packages and versions that your package needs
    + Versions are optional
    + Depends: Attaches!
    + Imports: Loads!
* Suggests
    + Added functionality
]

.pull-right-50[
* LazyData
    + Datasets occupy no memory until loaded
* License
    + Can be a file; LICENSE
    + Influences permissions of who can distribute and modify in what way
    + Most common; MIT, GPL-3, CC0.
    + https://tldrlegal.com/
    + CRAN requires a license

]

???

The Depends and Imports fields of DESCRIPTION handles what packages, and optionally what versions of packages, your package needs to work. The big difference here is that depends attaches the functions, something that is generally frowned upon for packages, and imports loads them, making them available for use. So usually you will see Depends on R version and most other packages in Imports.
Suggests isnt packages that your package needs to function properly but with those packages there can be added functionality. For example a package can create a plot using base R plotting tools but you have built in that if ggplot2 is available create pretties plots instead.
LazyData is a special function which should be true which states that any datasets included in your package should not take any memory until they are used.
The license of your package should reflect who and how your package should be used or modified. If the license is longer than just a standard abbreviation it can be a file, called LICENSE.

---

# Versioning

<center>
.largest[0.0.0.9000]
</center>

--

<center>
.large[major.minor.patch.dev]
</center>

<br>
* Major
  + Large changes, not always backwards compatible
  + Usually 1 upon first release out of dev
* Minor
  + Bug fixes & new features. Most common
* Patch
  + Small bugfixes, no new features.
* Dev
  + Only used while under development
  + Always starts at 9000

???

Wether you are developing your package, or updating and adding to a released package, it is good to change the version numbers in your DESCRIPTION file to reflect the changes. The four numbers reflect the kind of change that you have made to the package. Dev should be removed from the package upon release.

---
name: man

# man/

.pull-left-30[
<img src="data/slide_rpackage/tree_rpkg.png">
]

???

Documentation of your functions is important for helping users know how to use your package, and also for yourself when you come back to the package. The documentation is in the man/ directory in "R documentation", or Rd files. They contain the information you see when you call ?function. While you can write these by hand it is easier and handsomer to have the package roxygen2 generate them for you.

--

.pull-right-70[
* `Roxygen2`
  + ?function
  + Comment block, `#'`, preceding a function
  + Tags, `@tags`, map values
  + No tag for introduction
      + title*
      + description
      + details
  + Special characters `@\%`, escape with `\`
]

.small[*call_me.R*]
```
#' Output "Call me " followed by input.
#'
#' @param x A character or characters.
#' @return The string "Call me " and \code{x}. I'll write this
#'    to display how to section with tags.
#' @examples
#' call_me("Maeby")
call_me <- function(x) {
  paste("Call me ", x, sep="")
}
```


???

Roxygen2 works with special comment blocks in your code, directly before the function you are documenting, to create the Rd files. So you are actually writing your documentation in the same place as your code, the .R file, which is easier than going to another file and updating it. It also reminds you as you update your code to update the documentation in a natural way, and roxygen even deducts some information by itself so it is faster to write documentation.
Here is an example function call_me.R with the roxygen2 documentation block preceding it. The first line will become the title and also the description if none is given. @param documents the parameter x, @return lets us know what the function returns, and notice the indentation here which I have added to signify how to add multiple rows of text and have them belong together. @examples shows one or many example executions of the code.

---

# man/

.pull-left-60[
.small[
*call_me.R*
```
#' Output "Call me " followed by input.
#'
#' @param x A character or characters.
#' @return The string "Call me " and \code{x}. I'll write this
#'    to display how to section with tags.
#' @examples
#' call_me("Maeby")
call_me <- function(x) {
  paste("Call me ", x, sep="")
}
```]

.small[
*call_me.Rd*
```
% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/call_me.R
\name{call_me}
\alias{call_me}
\title{Output "Call me " followed by input.}
\usage{
call_me(x)
}
\arguments{
\item{x}{A character or characters.}
}
\value{
The string "Call me " and \code{x}. I'll write this
   to display how to section with tags.
}
\description{
Output "Call me " followed by input.
}
\examples{
call_me("Maeby")
}
```]
]

???

So when your documentation is built, roxygen takes the block information and generates a Rd file that looks like this.

--

.pull-right-40[
<br><br>
.small[\>*?call_me*]
<img src="data/slide_rpackage/rdexample.png">
]

???
And when you do question mark the function name in R the Rd file is parsed and you get this helpful documentation that I am sure you are all familiar with. I know this is a busy slide but what I hope I have been able to convey to you is that you use the code block in the .R code file which roxygen2 parses to create the Rd file which in turn is what is read when you ask for the documentation of a function in R.


---

# man/ for datasets

.pull-left-30[
<img src="data/slide_rpackage/tree_rpkg.png">
]

???
We will get to datasets later but while I am talking about documentation you should also document your datasets, if you have any. It is very similar to functional documentation, my dataset is the publicly available ToothGrowth dataset and I have created a R file called data.R where I will add documentation.

--

.pull-right-70[
```{r}
head(ToothGrowth)
```
<br><br>
]

???
Here we see the head of the ToothGrowth dataset.
--

.small[
*data.R:*
```
#' The Effect of Vitamin C on Tooth Growth in Guinea Pigs
#'
#' The response is the length of odontoblasts (cells responsible for tooth growth)
#'   in 60 guinea pigs. Each animal received one of three dose levels of vitamin C
#'   (0.5, 1, and 2 mg/day) by one of two delivery methods, orange juice or ascorbic
#'   acid (a form of vitamin C and coded as VC).
#'
#' @usage ToothGrowth
#'
#' @format A data frame with 60 observations on 3 variables.
#' \describe{
#'   \item{len}{Tooth length}
#'   \item{supp}{Supplement type (VC or OJ).}
#'   \item{dose}{Dose in milligrams/day}
#' }
#' @source \url{https://www.elsevier.com/books/the-statistics-of-bioassay/bliss/978-1-4832-5662-7}
"ToothGrowth"
```
]

???
And here we see the documentation, which I have put in data.R. Just like previously this is then parsed by roxygen2 when I give the command and ToothGrowth.Rd is created. First title, then description, the usage in this case is just the dataset, and the @format describes the data, not @params that described our functions parameters. At the very end we see just the name of the dataset, which lives in ToothGrowth.RData.

---
name: vig

# vignettes/

* A more complete guide to your package
  + For user/you
  + Examples and use cases
* `knitr` & `rmarkdown`
  + `knitr`: add r code to markdown
* `vignettes/package-vignette.Rmd`


???
Vignettes are a long-form guide, or manual, to the package that details what the functions in the package can do. It can also show and give examples of what the package is designed to do, using multiple functions in sequence. If functional documentation shows just a part, think of the vignette as a book chapter showing what your package can do. It can look very different if you intend it for your users or for yourself to read at a later date. You can use many things to create the vignette, but like with roxygen2 probably the easiest is to use knitr and rmarkdown.

--

```
usethis::use_vignette("typicalr-vignette")
```
.small[*typicalr-vignette.Rmd*]
```
  ---
  title: "Vignette Title"
  author: "Vignette Author"
  date: "`r Sys.Date()`"
  output: rmarkdown::html_vignette
  vignette: >
    %\VignetteIndexEntry{Vignette Title}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
  ---
```

???
What we are seeing here is the top metadata of a template for a vignette that I created using usethis::use_vignette("typicalr-vignette") which created typicalr-vignette.Rmd and the vignettes/ directory. It also edits DESCRIPTION, adding knitr and rmarkdown to suggests, and adding VignetteBuilder: knitr. You are free to edit any part of the rmarkdown file but should not change the structure of the metadata. Only add the title in both places where it says "Vignette title" and your name as author. You can also change the output to pdf vignette for example.
Luckily you have already gone through rmarkdown, so we dont need to talk about that, =).

---

# vignettes/

* A more complete guide to your package
  + For user/you
  + Examples and use cases
* `knitr` & `rmarkdown`
  + `knitr`: add r code to markdown
* `vignettes/package-vignette.Rmd`

```
usethis::use_vignette("typicalr-vignette")
```
.small[*typicalr-vignette.Rmd*]
```
  ---
  title: "typicalr"
  author: "Sebastian DiLorenzo"
  date: "`r Sys.Date()`"
  output: rmarkdown::html_vignette
  vignette: >
    %\VignetteIndexEntry{typicalr}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
  ---
```

---
name: namespace

# NAMESPACE

.center[package1 names &emsp; &emsp; &emsp; &emsp; package2 names]
.center[<img src="data/slide_rpackage/venn.png">]

???
The namespace makes sure your package works well with other packages, so it is mostly important for submitting to repository, CRAN. It makes sure your code and the code of other packages doesnt interfere with eachother. I like to think of it as a venn diagram, where each circle is a space filled with names. What the namespace does is remove the overlap, so if your function uses a function from package1, it wont accidentally use a function with the same name from package2. It does this by specifying which space a function should look for the name of a function it needs.

--

* `@imports` and `@importsFrom`
  + Defines how/where a function in one package finds a function in another
  + `@imports` *pkg*
  + `@importsFrom` *pkg function*
* `@export`
  + Defines which functions are available to user
  + Do not export data

???
It does this using imports and exports.
Like the other documentation, we can use roxygen2 to create our namespace. Using the imports tag, it doesnt matter if our user has loaded a package with a function with the same name as one of our functions are using, because our function will know to use the one specified in imports. Exports helps by saying that only these functions of my package are available outside. If you export all your functions, it increases the risk of being incompatible with other packages, so good practice is to export as few as possible.
If you are not going to share your package, just export every function.

---

# NAMESPACE

.small[*call_me.R:*]
```
#' Output "Call me " followed by input.
#'
#' @param x A character or characters.
#' @return The string "Call me " and \code{x}. I'll write this
#'    to display how to section with tags.
#' @examples
#' call_me("Maeby")
#' @export
call_me <- function(x) {
  paste("Call me ",x,sep="")
}
```

.small[*utility.R:*]
```
#' @import knitr
NULL
```

???
Revisiting call_me.R, I have now added the @export tag, and in the utility.R I have @import knitr, just as an example, using the NULL object since there has to be something there.

--

.small[*NAMESPACE:*]
```
# Generated by roxygen2: do not edit by hand

export(call_me)
import(knitr)
```


???
So when I run devtools::document(), just like when we generated the other documentation, this will generate the NAMESPACE for us. Notice that this is a very minimal example and roxygen2 actually looks at what you are exporting so there are added benefits here where you are just writing @export but roxygen2 is correctly exporting it as a S3 or S4 class etc.

---

# NAMESPACE

.center.large[Import in **DESCRIPTION** and in **NAMESPACE**!?]

???
A final note on the namespace is that at a glance we are now importing packages both in the DESCRIPTION and in the NAMESPACE. This is more an accident of naming as they are doing a bit different things.

--
<br><br><br><br>
* DESCRIPTION `Imports:`
  + "My package needs this package to work"
* NAMESPACE `@import`
  + "When my package uses this function, use the one from the package in the NAMESPACE"

* Additional effects:
  + NAMESPACE removes need for `::`
      + `package::function()` or `function()`

???
When you import a function in DESCRIPTION you are saying that "My package needs this package to work", when you import a function in NAMESPACE you are saying "When my package uses this function, use the one from the package in the NAMESPACE" even if there exist functions with the same name.
An added benefit is that if you just import a package in DESCRIPTION you need to specify in your code which package it is from as it is not attached but if you import it from NAMESPACE this need is removed.
Finally: Realise that writing package::function() removes the need to import functions to NAMESPACE and is best, but it takes a while to write of course.

---
name: data

# data/

.pull-left-50[
**Package types:**
* Functional
  + Performs a or several functions
  + Contains no or small datasets, <1 MB
* Dataset
  + Contains an interesting dataset
  + Easy to import
  + Few or no functions
]

???
Including data is good if there is some information intrinsic to some of your functions or to provide examples of usage. In some packages it can be the main reason for the package, for example a R package carrying some census data which is easy for people to load. Unless your package is such a data package you should strive to keep it less than 1 MB.

--

.pull-right-50[
**Data types:**
* Binary data, `.Rdata` or `.rda`
    + `data/` folder
    + A single object with the same name as the data file
* Function data
    + `R/sysdata.rda`
    + Data that your functions need
* Raw data, `.xlsx`,`.csv` etc
    + `inst/extdata`folder
]

???
You can have three types of data in R, binary data is an R object saved to data/ directory with the same name as the object. These can be slightly larger files.
Data that your functions need, for example in life sciences you might save the positions of the centromeres within a package that plots the genome, or for a plotting program you may want to save a list of colors, this is usually saved in R/sysdata.rda. The objects saved there will be available to your functions by name within the package.
If you want to include raw data, usually you should try not to or convert it to binary data, you can save those in inst/extdata.

--

.pull-out[
```
#Create data in package automatically
usethis::use_data(object, package)

#Manually
save(object, file="path/to/package/data/object.Rdata")

#Access raw data
system.file("extdata","filename.csv", package="packagename")
```
]

???
Here we see some code where we use usethis to save a object directly to data/ directory with the correct name. This is the same thing basically as using the save command and pointing to the correct location, with correct filename. If you want to access data belongning to a package you can use the system.file command in R.

---
name: src

# src/

.pull-left-50[
* Compiled code
  + `Rcpp`
  + `rJava`
* Scripts
  + `inst/`
  + Dependencies
]

???
I wont go deeply into this, but I want it to be something you are aware of.
R isnt the fastest language, so sometimes you may want to put for example C or C++ in your package for certain functions. There are two ways to go about this.
Either you can integrate, using packages such as Rcpp, or rJava and others, or you just straight up put code such as .py files in inst/python. This should be avoided as it creates additional dependencies on the user. So lets look at an example of how to set up your package to use Rcpp, which is probably the easiest and most common.

--

.pull-right-50[
1. `usethis::use_rcpp()`
    + Edit DESCRIPTION
    + `#' @useDynLib packagename`
    + `#' @importFrom Rcpp sourceCpp`
2. `.cpp` file in `src/`
]

.pull-out.smallish[
*src/filename.cpp:*
```
#include <Rcpp.h>
using namespace Rcpp;

// This is a simple example of exporting a C++ function to R. You can
// source this function into an R session using the Rcpp::sourceCpp
// function (or via the Source button on the editor toolbar). Learn
// more about Rcpp at:
//
//   http://www.rcpp.org/
//   http://adv-r.had.co.nz/Rcpp.html
//   http://gallery.rcpp.org/
//

// [[Rcpp::export]]
NumericVector timesTwo(NumericVector x) {
  return x * 2;
}

```
  ]

???
First you can call usethis::use_rcpp() which automates the processes of adding information to your DESCRIPTION and telling you to add two tags for documentation somewhere in your packages code. Then we create a c++ file, from Rstudio preferable, in our src/ folder. It will look as shown here by default. The only important parts are the header and the rcpp::export located above the example function.

---

# src/

.pull-left-50[
* Compiled code
  + `Rcpp`
  + `rJava`
* Scripts
  + `inst/`
  + Dependencies
]

.pull-right-50[
1. `usethis::use_rcpp()`
    + Edit DESCRIPTION
    + `#' @useDynLib packagename`
    + `#' @importFrom Rcpp sourceCpp`
2. `.cpp` file in `src/`
3. `pkgbuild::compile_dll()`
4. `devtools::document()`
5. `Build & Reload`
6. Add documentation to `.cpp`
]

.pull-out[
*R/RcppExports.R:*
```
# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

timesTwo <- function(x) {
    .Call('_typicalr_timesTwo', PACKAGE = 'typicalr', x)
}
```
]

???
To get this to R code we first build the documentation, which exports the function, and your tags for using rcpp, to NAMESPACE, and then Build & Reload in Rstudio, I am sure there are ways to do this with devtools as well. At this stage the cpp function is callable in R, through the RcppExports.R file that has been created in R/ directory, which looks like this. Just like with our normal functions we can add roxygen documentation for this in the cpp file.

---
name: git
class: spaced

# git, Github, Rstudio and you!

.pull-left-50[
* `git`
  + Version control
  + Working in groups
  + Rstudio integration
* Github
  + Unoffical repository
  + `devtools::install_github()`
  + R Package development environment
  + Issues
]

.pull-right-50[
<img src="data/slide_rpackage/github.png">
]

???
That was all I was going to say about the different pieces of a package. There are more but I think those are the main parts and you can dive into the others if you are making an advanced package.
Now let's talk alittle about hosting your package. Using version control, such as git, is a good way to work on your package, especially if you are working on it in a group. This is because it keeps track of changes and conflicts so that if multiple people are working on the same file no bugs appear. You can also setup Rstudio to work with git and github. A package hosted on github can be directly installed using devtools::install_github() and what you see more and more nowadays is that a stable release is on CRAN whereas development versions are on github. It is also a great place for others to contribute to your code and to report issues they have with your package.

---
name: cran

# CRAN and `R CMD check`

.pull-left-60[
* **C**omprehensive **R** **A**rchive **N**etwork
  + R package repository
  + Sign of quality
* `R CMD check`
  + More than 50 individual checks
  + Three messages:
      + **ERROR**: Always fix.
      + **WARNING**: Should probably fix. Definitely for CRAN submit.
      + **NOTE**: Try to solve to CRAN submit, else do not bother.
  + `devtools::check()`
]

.pull-right-40[
<img src="data/slide_rpackage/Rlogo.svg", style="width:80%">
]

???
R CMD check is a command that checks your package for common problems. From filenames and permissions to information in DESCRIPTION and NAMESPACE and wether you can install it. Note that this can only check if it is installable in your current environment, not on other operating systems. It also checks that your package is compatible with CRAN, such as not having the same name as a package that already exists there and that the required information in DESCRIPTION is present. It also checks your actual code, making sure that there are no problems or dependencies that are not met.
There are three types of messages that R CMD CHECK can complain about. Errors are always bad, and you should fix them no matter what. Warnings are pretty bad, but there may be some false positives. You should try to fix them especially if you are submitting the package to cran. Notes you can take or leave, but if you are a completionist you should aspire to fix even these.
As with most other commands, devtools has a function for this called check() which performs r cmd check and some additional operations such as automatically updating the documentation and bundling the package before checking.

--

.pull-right-40[
<br>
<img src="data/slide_rpackage/TravisCI.png", style="width:80%">
]

.pull-left-60[
* Travis-CI
  + Integrated with your github repository
  + Automates `R CMD check`
  + Multiple operating systems
]

???
If you are developing your package on github you can set up Travis to run this check every time you commit your package. One of the best things is that it tests it for multiple different operating systems.

---
class: spaced

# Summary

.pull-left-70[
* [What is an R package?](#rpkg)
* [Possible package states](#pkg-states)
<!-- * [Repositories](#)Include? -->
* Package structure:
    + [Code | `r/`](#r)
    + [Metadata | `DESCRIPTION`](#desc)
    + [Documentation | `man/`](#man)
    + [Vignettes](#vig)
    + [Import & Export | `NAMESPACE`](#namespace)
    + [Data | `data/`](#data)
    + [Compiled code | `src/`](#src)
<!--    + [Installed files | `inst/`](#) Include? -->
<!-- * [Testing](#)  Include? -->
* [git, Github, Rstudio and you!](#git)
* [CRAN and `R CMD check`](#cran)
<!-- * [Package website | `pkgdown`](#)  Include? -->
]

.pull-right-30[
<img src="data/slide_rpackage/rpkg_book.png">
.small[http://r-pkgs.had.co.nz/]
]

---
name: end-slide
class: end-slide

# Thank you. Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

<!--chapter:end:slide_rpackage.Rmd-->

---
title: "Tidy work in Tidyverse"
subtitle: "R Foundation for Life Scientists"
author: "Marcin Kierczak"
keywords: r, r programming, markdown, tidyverse
output:
  xaringan::moon_reader:
    encoding: 'UTF-8'
    self_contained: false
    chakra: 'assets/remark-latest.min.js'
    css: 'assets/slide.css'
    lib_dir: libs
    include: NULL
    nature:
      ratio: '4:3'
      highlightLanguage: r
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%/%total%"
---

exclude: true
count: false

```{r,echo=FALSE,child="assets/header-slide.Rmd"}
```

<!-- ----------------- Only edit title & author above this ----------------- -->

```{r setup,include=FALSE}
knitr::opts_chunk$set(dev="png",results="hold",fig.show="hold",fig.align="left",echo=TRUE,warning=FALSE,message=FALSE)
options(crayon.enabled = FALSE)

# report related
library(knitr)
library(markdown)
library(rmarkdown)
```

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# load the packages you need

library(tidyverse)
library(ggplot2) # static graphics
library(kableExtra)
library(magrittr)
```

# Tidyverse -- What is it all About?

* [Tidyverse](http://www.tidyverse.org) is a collection of packages.
* Created by [Hadley Wickham](http://hadley.nz).
* Gains popularity, on the way to become a *de facto* standard in data analyses.
* Knowing how to use it can increase your salary :-)
* A philosophy of programming or a programing paradigm.
* Everything is about the flow of *tidy data*.
.center[
<img src="data/slide_tidyverse/hex-tidyverse.png", style="height:200px;">
<img src="data/slide_tidyverse/Hadley-wickham2016-02-04.jpeg", style="height:200px;">
<img src="data/slide_tidyverse/RforDataScience.jpeg", style="height:200px;">
]
.vsmall[sources of images: www.tidyverse.org, Wikipedia, www.tidyverse.org]

---
name: tidyverse_workflow

# Typical Tidyverse Workflow

The tidyverse curse?

--

> Navigating the balance between base R and the tidyverse is a challenge to learn. [-Robert A. Muenchen](http://r4stats.com/articles/why-r-is-hard-to-learn/)

--

.center[<img src="data/slide_tidyverse/tidyverse-flow.png", style="height:400px;">]

.vsmall[source: http://www.storybench.org/getting-started-with-tidyverse-in-r/]

---
name: intro_to_pipes

# Introduction to Pipes

.pull-left-50[

.center[<img src="data/slide_tidyverse/pipe_magritte.jpg", style="width:300px;">]

.vsmall[Rene Magritt, *La trahison des images*, [Wikimedia Commons](https://en.wikipedia.org/wiki/The_Treachery_of_Images#/media/File:MagrittePipe.jpg)]

.center[<img src="data/slide_tidyverse/magrittr.png", style="width:150px;">]
]

--

.pull-right-50[

* Let the data flow.
* *Ceci n'est pas une pipe* -- `magrittr`
* The `%>%` pipe:
  + `x %>% f` $\equiv$ `f(x)`
  + `x %>% f(y)` $\equiv$ `f(x, y)`
  + `x %>% f %>% g %>% h` $\equiv$ `h(g(f(x)))`

]

--

.pull-right-50[

instead of writing this:

```{r magrittr0, eval=F}
data <- iris
data <- head(data, n=3)
```

]

--

.pull-right-50[

write this:

```{r magrittr1}
iris %>% head(n=3)
```

]


---
name: tibble_intro

# Tibbles

.pull-left-50[

.center[<img src="data/slide_tidyverse/hex-tibble.png">]

```{r}
head(as_tibble(iris))
```

]

.pull-right-50[

* `tibble` is one of the unifying features of tidyverse,
* it is a *better* `data.frame` realization,
* objects `data.frame` can be coerced to `tibble` using `as_tibble()`

```{r tibble_from_scratch}
tibble(
  x = 1,          # recycling
  y = runif(8),
  z = x + y^2,
  outcome = rnorm(8)
)
```

]

---
name: tibble2

# More on Tibbles

* When you print a `tibble`:
  + all columns that fit the screen are shown,
  + first 10 rows are shown,
  + data type for each column is shown.

```{r tibble_printing}
as_tibble(cars) %>% print(n = 5)
```

* `my_tibble %>% print(n = 50, width = Inf)`,
* `options(tibble.print_min = 15, tibble.print_max = 25)`,
* `options(dplyr.print_min = Inf)`,
* `options(tibble.width = Inf)`

---
name: tibble2

# Subsetting Tibbles

```{r tibble_subs}
vehicles <- as_tibble(cars[1:5,])

vehicles[['speed']]
vehicles[[1]]
vehicles$speed

# Using placeholders

vehicles %>% .$dist
vehicles %>% .[['dist']]
vehicles %>% .[[2]]
```

--

**Note!** Not all old R functions work with tibbles, than you have to use `as.data.frame(my_tibble)`.

---
name: tibbles_partial_matching

# Tibbles are Stricter than `data.frames`

```{r tibble_strict, warning=T, echo=F}
cars <- cars[1:5,]
```
```{r tibble_strict1, warning=T}
cars$spe      # partial matching
```
```{r tibble_strict2, warning=T}
vehicles$spe  # no partial matching
```
```{r tibble_strict3, warning=T}
cars$gear
```
```{r tibble_strict4, warning=T}
vehicles$gear
```

---
name: loading_data

# Loading Data

In `tidyverse` you import data using `readr` package that provides a number of useful data import functions:
* `read_delim()` a generic function for reading *-delimited files. There are a number of convenience wrappers:
  + `read_csv()` used to read comma-delimited files,
  + `read_csv2()` reads semicolon-delimited files,
  `read_tsv()` that reads tab-delimited files.
* `read_fwf` for reading fixed-width files with its wrappers:
  + fwf_widths() for width-based reading,
  + fwf_positions() for positions-based reading and
  + read_table() for reading white space-delimited fixed-width files.
* `read_log()` for reading Apache-style logs.

--
The most commonly used `read_csv()` has some familiar arguments like:
* `skip` -- to specify the number of rows to skip (headers),
* `col_names` -- to supply a vector of column names,
* `comment` -- to specify what character designates a comment,
* `na` -- to specify how missing values are represented.

---
name: readr

# Importing Data Using `readr`

When reading and parsing a file, `readr` attempts to guess proper parser for each column by looking at the 1000 first rows.

```{r tricky_dataset, echo=TRUE, message=TRUE, warning=T}
tricky_dataset <- read_csv(readr_example('challenge.csv'))
```

OK, so there are some parsing failures. We can examine them more closely using `problems()` as suggested in the above output.

---
name: readr_problems

# Looking at Problematic Columns

```{r tricky_dataset_problems}
(p <- problems(tricky_dataset))
```

OK, let's see which columns cause trouble:

```{r problems_table}
p %$% table(col)
```

Looks like the problem occurs only in the `x` column.

---
name: readr_problems_fixing

# Fixing Problematic Columns

So, how can we fix the problematic columns?

1. We can explicitely tell what parser to use:

```{r fix_problematic_explicite_parser, echo=TRUE, message=TRUE, warning=T}
tricky_dataset <- read_csv(readr_example('challenge.csv'),
                           col_types = cols(x = col_double(),
                                            y = col_character()))
tricky_dataset %>% tail(n = 5)
```

As you can see, we can still do better by parsing the `y` column as *date*, not as *character*.

---
name: readr_problems_fixing2

# Fixing Problematic Columns cted.

But knowing that the parser is guessed based on the first 1000 lines, we can see what sits past the 1000-th line in the data:

```{r}
tricky_dataset %>% head(n = 1002) %>% tail(n = 4)
```

It seems, we were very unlucky, because up till 1000-th line there are only integers in the x column and `NA`s in the y column so the parser cannot be guessed correctly. To fix this:

```{r guess_max_fix, echo=TRUE, message=TRUE, warning=T}
tricky_dataset <- read_csv(readr_example('challenge.csv'),
                           guess_max = 1001)
```

---
name: readr_writing

# Writing to a File

The `readr` package also provides functions useful for writing tibbled data into a file:

* `write_csv()`
* `write_tsv()`
* `write_excel_csv()`

They **always** save:

* text in UTF-8,
* dates in ISO8601

But saving in csv (or tsv) does mean you loose information about the type of data in particular columns. You can avoid this by using:

* `write_rds()` and `read_rds()` to read/write objects in R binary rds format,
* use `write_feather()` and `read_feather()` from package `feather` to read/write objects in a fast binary format that other programming languages can access.

---
name: basic_data_transformations

# Basic Data Transformations with `dplyr`

Let us create a tibble:

```{r}
(bijou <- as_tibble(diamonds) %>% head(n = 10))
```

.center[<img src="data/slide_tidyverse/diamonds.png", style="height:200px">]

---
name: filter

# Picking Observations using `filter()`

```{r}
bijou %>% filter(cut == 'Ideal' | cut == 'Premium', carat >= 0.23) %>% head(n = 5)
```

Be careful with floating point comparisons! Also, rows with comparison resulting in `NA` are skipped by default!

```{r}
bijou %>% filter(near(0.23, carat) | is.na(carat)) %>% head(n = 5)
```

---
name: arrange

# Rearranging Observations using `arrange()`

```{r}
bijou %>% arrange(cut, carat, desc(price))
```

The `NA`s always end up at the end of the rearranged tibble.

---
name: select

# Selecting Variables with `select()`

Simple `select` with a range:

```{r}
bijou %>% select(color, clarity, x:z) %>% head(n = 4)
```

--

Exclusive `select`:
```{r}
bijou %>% select(-(x:z)) %>% head(n = 4)
```

---
name: select2

# Selecting Variables with `select()` cted.

`rename` is a variant of `select`, here used with `everything()` to move `x` to the beginning and rename it to `var_x`

```{r}
bijou %>% rename(var_x = x) %>% head(n = 5)
```

--

use `everything()` to bring some columns to the front:

```{r}
bijou %>% select(x:z, everything()) %>% head(n = 4)
```

---
name: mutate

# Create/alter new Variables with `mutate`

```{r}
bijou %>% mutate(p = x + z, q = p + y) %>% select(-(depth:price)) %>% head(n = 5)
```

--

or with `transmute` (only the transformed variables will be retained)

```{r}
bijou %>% transmute(carat, cut, sum = x + y + z) %>% head(n = 5)
```

---
name: grouped_summaries

# Group and Summarize

```{r}
bijou %>% group_by(cut) %>% summarize(max_price = max(price),
                                      mean_price = mean(price),
                                      min_price = min(price))
```

--

```{r}
bijou %>% group_by(cut, color) %>%
  summarize(max_price = max(price),
            mean_price = mean(price),
            min_price = min(price)) %>% head(n = 4)
```

---
name: other_data_manipulations

# Other data manipulation tips

```{r}
bijou %>% group_by(cut) %>% summarize(count = n())
```

--

When you need to regroup within the same pipe, use `ungroup()`.

---
name: concept_of_tidy_data

# The Concept of Tidy Data

Data are tidy *sensu Wickham* if:
* each and every observation is represented as exactly one row,
* each and every variable is represented by exactly one column,
* thus each data table cell contains only one value.
`r knitr::include_graphics("data/slide_tidyverse/tidy_data.png")`

Usually data are untidy in only one way. However, if you are unlucky, they are really untidy and thus a pain to work with...

---
name: tidy_data

# Tidy Data

<img src="data/slide_tidyverse/tidy_data.png" style="height:100px">

--

.center[**Are these data tidy?**]

.pull-left-70[
```{r tidy_iris1, echo=FALSE}
data("iris")
iris %>% head(n=3) %>% kable("html",escape=F,align="c") %>%
  kable_styling(bootstrap_options=c("striped","hover","responsive","condensed"),
                position="left",full_width = F)
```
]

--

.pull-right-30[

```{r tidy_iris2, echo=FALSE}
iris2 <- iris %>%
  gather(key=variable, value=value, -Species)
iris2 %>%
  head(n=3) %>%
  kable("html",escape=F,align="c") %>%
  kable_styling(bootstrap_options=c("striped","hover","responsive","condensed"),
                position="left",full_width = F)
```

]

<br>&nbsp;<hr><br>

--
.pull-left-50[

```{r tidy_iris3, echo=FALSE}
iris3 <-
  iris %>%
  unite(Sepal.L.W, Sepal.Length, Sepal.Width, sep = "/") %>%
  unite(Petal.L.W, Petal.Length, Petal.Width, sep = "/")
iris3 %>%
  head(n = 3) %>%
  kable("html",escape=F,align="c") %>%
  kable_styling(bootstrap_options=c("striped","hover","responsive","condensed"),
                position="left",full_width = F)
```

]

--

.pull-right-50[
```{r tidy_iris4, echo=FALSE}
iris4 <- t(iris)
iris4[,1:4] %>%
  kable("html",escape=F,align="c") %>%
  kable_styling(bootstrap_options=c("striped","hover","responsive","condensed"),
                position="left",full_width = F)
```

]

---
name: tidying_data_pivot_longer

# Tidying Data with `tidyr::pivot_longer`

If some of your column names are actually values of a variable, use `pivot_longer` (replaces `gather`):

```{r include=FALSE}
bijou %>%
  mutate(`2008` = price) %>%
  select(-price) %>%
  mutate(`2009` = `2008` + sample(rnorm(100, mean = 0.01 * mean(`2008`)),
                                size = 1,
                                replace=T
                                )
         ) %>%
  select(cut, `2008`, `2009`) -> bijou2
```
```{r bijou2}
bijou2 %>% head(n = 5)
```
```{r}
bijou2 %>%
  pivot_longer(c(`2008`, `2009`), names_to = 'year', values_to = 'price') %>%
  head(n = 5)
```

---
name: tidying_data_pivot_wider

# Tidying Data with `tidyr::pivot_wider`

If some of your observations are scattered across many rows, use `pivot_wider` (replaces `gather`):

```{r include=FALSE}
bijou %>% head(n = 3) %>% select(cut, price, clarity, x, y, z) %>% gather(x,y,z, key='dimension', value='measurement') -> bijou3
```

```{r bijou3}
bijou3
```

```{r}
bijou3 %>%
  pivot_wider(names_from=dimension, values_from=measurement) %>%
  head(n = 4)
```

---
name: tidying_data_separate

# Tidying Data with `separate`

If some of your columns contain more than one value, use `separate`:

```{r include=FALSE}
bijou %>% head(n = 5) %>% select(cut, price, clarity, x, y, z) %>% unite(dim, x, y, z, sep='/') -> bijou4
```
```{r bijou4}
bijou4
```
```{r}
bijou4 %>%
  separate(dim, into = c("x", "y", "z"), sep = "/", convert = T)
```

---
name: tidying_data_separate

# Tidying Data with `unite`

If some of your columns contain more than one value, use `separate`:

```{r include=FALSE}
bijou %>% head(n = 5) %>% select(cut, price, clarity, x, y, z) %>% separate(clarity, into = c('clarity_prefix', 'clarity_suffix'), sep = 2) -> bijou5
```
```{r bijou5}
bijou5
```
```{r}
bijou5 %>% unite(clarity, clarity_prefix, clarity_suffix, sep='')
```

**Note:** that `sep` is here interpreted as the position to split on. It can also be a *regular expression* or a delimiting string/character. Pretty flexible approach!

---
name: missing_complete

# Completing Missing Values Using `complete`

```{r eval=FALSE, include=FALSE}
bijou %>%
  head(n = 10) %>%
  select(cut, clarity, price) %>%
  mutate(cut, cut2=replace(cut, sample(1:10, 4, F), NA)) -> missing_stones
```
```{r}
bijou %>% head(n = 10) %>%
  select(cut, clarity, price) %>%
  mutate(continent = sample(c('AusOce', 'Eur'),
                            size = 10,
                            replace = T)) -> missing_stones
```
```{r}
missing_stones %>% complete(cut, continent)
```

---
name: more_tidyverse

# Some Other Friends

* `stringr` for string manipulation and regular expressions,
* `forcats` for working with factors,
* `lubridate` for working with dates.

---
name: end-slide
class: end-slide

# Thank you. Questions?

```{r,echo=FALSE,child="assets/footer-slide.Rmd"}
```

<!--chapter:end:slide_tidyverse.Rmd-->

